# ================= IMPORTS OTIMIZADOS =================
import discord
from discord.ext import commands, tasks
from discord.ui import Button, View, Modal, TextInput, Select
import os
import sys
import sqlite3
import asyncio
import random
import logging
import aiohttp
import time
from datetime import timedelta, datetime, timezone
from discord.ext.commands import BucketType
from pathlib import Path
from dotenv import load_dotenv
import collections
import threading




# =============== SISTEMA ANTI-DUPLICA√á√ÉO DE COMANDOS ===============
class SafeBot(commands.Bot):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._registered_commands = set()

    def safe_command(self, name: str, **kwargs):
        """Decorator seguro para comandos"""
        def decorator(func):
            if name in self._registered_commands:
                print(f'‚ö†Ô∏è Comando "{name}" j√° registrado. Ignorando duplicata.')
                return func
            self._registered_commands.add(name)
            return commands.command(name=name, **kwargs)(func)
        return decorator

# ================= CONFIGURA√á√ïES GLOBAIS E LOGS =================
LAST_WALLET_MESSAGES = {}

# Configura√ß√£o avan√ßada de logging com arquivo
import logging
from logging.handlers import RotatingFileHandler

# Cria logger principal
logger_main = logging.getLogger('BotDebug')
logger_main.setLevel(logging.DEBUG)

# Handler para arquivo rotativo (m√°x 5MB, 3 backups)
log_path = Path(__file__).parent / "bot_debug.log"
file_handler = RotatingFileHandler(log_path, maxBytes=5*1024*1024, backupCount=3, encoding='utf-8')
file_handler.setLevel(logging.DEBUG)

# Handler para console
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# Formata√ß√£o detalhada
detailed_formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
)
file_handler.setFormatter(detailed_formatter)
console_handler.setFormatter(detailed_formatter)


# Dicion√°rio para rastrear execu√ß√µes de comandos
command_executions = collections.defaultdict(list)
duplicate_alerts = {}

def log_command_execution(command_name, user_id, context):
    """Registra execu√ß√£o de comando para detectar duplica√ß√µes"""
    current_time = datetime.now()
    
    # Adiciona execu√ß√£o √† lista
    command_executions[f"{command_name}_{user_id}"].append({
        'timestamp': current_time,
        'context': context,
        'channel_id': getattr(context, 'channel_id', 'unknown'),
        'message_id': getattr(context, 'message_id', 'unknown')
    })
    
    # Limpa execu√ß√µes antigas (mais de 1 minuto)
    cutoff_time = current_time - timedelta(minutes=1)
    command_executions[f"{command_name}_{user_id}"] = [
        exec_data for exec_data in command_executions[f"{command_name}_{user_id}"]
        if exec_data['timestamp'] > cutoff_time
    ]

class BotLogger:
    @staticmethod
    def error(message):
        logging.error(f"‚ùå {message}")

    @staticmethod
    def debug(message):
        logging.debug(f"üîß {message}")

    @staticmethod
    def command_success(command, user, details=""):
        logging.info(f"‚úÖ Comando '{command}' executado por {user} {details}")

    @staticmethod
    def command_error(command, user, error):
        logging.error(f"‚ùå Comando '{command}' falhou para {user}: {error}")

logger = BotLogger()

# ================= CONFIGURA√á√ÉO DO BOT =================
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
intents.presences = True
intents.voice_states = True

bot = SafeBot(command_prefix='!', intents=intents, help_command=None)

# --- SISTEMA DE PERMISS√ïES AUTO-CONFIGUR√ÅVEL ---
CONFIG_DB_PATH = Path(__file__).parent / "perm_config.db"

def init_perm_db():
    """Inicializa o banco de dados de permiss√µes"""
    with sqlite3.connect(CONFIG_DB_PATH) as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS server_config (
            server_id INTEGER PRIMARY KEY,
            admin_role_id INTEGER DEFAULT NULL,
            mod_role_id INTEGER DEFAULT NULL,
            dono_bot_role_id INTEGER DEFAULT NULL,
            pd_role_id INTEGER DEFAULT NULL
        )""")
        conn.commit()

async def check_admin(ctx):
    """Verifica se o usu√°rio tem permiss√£o de administrador"""
    if await ctx.bot.is_owner(ctx.author):
        return True
    
    with sqlite3.connect(CONFIG_DB_PATH) as conn:
        config = conn.execute(
            "SELECT admin_role_id, dono_bot_role_id FROM server_config WHERE server_id = ?",
            (ctx.guild.id,)
        ).fetchone()
        
    if config:
        admin_role = ctx.guild.get_role(config[0]) if config[0] else None
        dono_role = ctx.guild.get_role(config[1]) if config[1] else None
        return any(role in ctx.author.roles for role in [admin_role, dono_role] if role)
    
    return ctx.author.guild_permissions.administrator

# ADICIONE O COMANDO SETUP AQUI
@bot.command(name='setup')
@commands.check(check_admin)
async def setup_bot(ctx, tipo: str, role: discord.Role):
    """Configura os cargos de permiss√£o

    Tipos: admin, mod, dono, pd
    Exemplo: !setup admin @Administradores
    """
    valid_types = ['admin', 'mod', 'dono', 'pd']
    if tipo.lower() not in valid_types:
        return await ctx.send(f"‚ùå Tipo inv√°lido! Use: {', '.join(valid_types)}")

TEST_MODE = False  # Alterado para False para usar SQLite real

if TEST_MODE:
    test_db = {
        'users': {},
        'warns': [],
        'families': [],
        'staff': []
    }

# ================= BANCO DE DADOS SQLITE =================

# Configura√ß√£o do banco de dados com verifica√ß√£o de permiss√µes
DB_PATH = Path(__file__).parent / "config.db"

# Garante que a pasta database existe e tem permiss√µes
try:
    DB_PATH.parent.mkdir(exist_ok=True, parents=True)
    # Verifica/cria o arquivo do banco de dados
    if not DB_PATH.exists():
        with open(DB_PATH, 'w'): pass  # Cria arquivo vazio
except Exception as e:
    print(f"Erro ao configurar banco de dados: {e}")
    # Fallback para local tempor√°rio se n√£o tiver permiss√£o
    DB_PATH = Path(os.getenv('TEMP', '/temp')) / "bot_data_fallback.db"
    print(f"Usando caminho alternativo: {DB_PATH}")

def get_db():
    if TEST_MODE:
        return test_db
    
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row  # Isso permite acesso por nome de coluna
        conn.execute("PRAGMA foreign_keys = ON")
        return conn
    except sqlite3.Error as e:
        print(f"Erro ao conectar ao banco de dados: {e}")
        raise

def init_db():
    global DB_PATH
    print(f"Inicializando banco de dados em: {DB_PATH}")
    
    if TEST_MODE:
        return
    
    success = False
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Cria√ß√£o das tabelas
        conn.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            money INTEGER DEFAULT 0,
            bank INTEGER DEFAULT 0,
            rep INTEGER DEFAULT 0,
            xp INTEGER DEFAULT 0,
            level INTEGER DEFAULT 1,
            last_daily TEXT,
            last_rep TEXT,
            about_me TEXT,
            vip INTEGER DEFAULT 0,
            vip_level INTEGER DEFAULT 0,
            family_id INTEGER
        )
        """)
        
        conn.execute("""
        CREATE TABLE IF NOT EXISTS warns (
            warn_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            moderator_id INTEGER,
            reason TEXT,
            timestamp TEXT
        )
        """)
        
        conn.execute("""
        CREATE TABLE IF NOT EXISTS families (
            family_id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            leader_id INTEGER,
            created_at TEXT
        )
        """)
        
        conn.execute("""
        CREATE TABLE IF NOT EXISTS staff (
            user_id INTEGER PRIMARY KEY,
            role TEXT,
            permissions TEXT,
            join_date TEXT
        )
        """)

        conn.execute("""
        CREATE TABLE IF NOT EXISTS primeira_dama (
            server_id INTEGER,
            user_id INTEGER,
            cargo_name TEXT,
            data_indicacao TEXT,
            PRIMARY KEY (server_id, user_id),
            FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
        )
        """)
        
        conn.execute("""
        CREATE TABLE IF NOT EXISTS minha_tabela (
            id INTEGER PRIMARY KEY,
            nome TEXT
        )
        """)
        
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_pd_server ON primeira_dama (server_id)
        """)
        
        conn.commit()
        
        # Consulta corrigida para listar tabelas
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = cursor.fetchall()
        
        print("Tabelas existentes no banco de dados:")
        for row in tables:
            print(f"- {row[0]}")  # Acessa por √≠ndice (0) em vez de nome
        
        success = True
    except sqlite3.Error as e:
        print(f"Erro ao inicializar banco de dados: {e}")
    
    if not success:
        fallback_db = Path(os.getenv('TEMP', '/temp')) / "bot_data_fallback.db"
        print(f"Tentando criar banco de dados em local alternativo: {fallback_db}")
        try:
            conn = sqlite3.connect(fallback_db)
            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA foreign_keys = ON")
            
            # Cria√ß√£o das tabelas no fallback
            conn.execute("""
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                money INTEGER DEFAULT 0,
                bank INTEGER DEFAULT 0,
                rep INTEGER DEFAULT 0,
                xp INTEGER DEFAULT 0,
                level INTEGER DEFAULT 1,
                last_daily TEXT,
                last_rep TEXT,
                about_me TEXT,
                vip INTEGER DEFAULT 0,
                vip_level INTEGER DEFAULT 0,
                family_id INTEGER
            )
            """)
            
            conn.execute("""
            CREATE TABLE IF NOT EXISTS warns (
                warn_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                moderator_id INTEGER,
                reason TEXT,
                timestamp TEXT
            )
            """)
            
            conn.execute("""
            CREATE TABLE IF NOT EXISTS families (
                family_id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                leader_id INTEGER,
                created_at TEXT
            )
            """)
            
            conn.execute("""
            CREATE TABLE IF NOT EXISTS staff (
                user_id INTEGER PRIMARY KEY,
                role TEXT,
                permissions TEXT,
                join_date TEXT
            )
            """)

            conn.execute("""
            CREATE TABLE IF NOT EXISTS primeira_dama (
                server_id INTEGER,
                user_id INTEGER,
                cargo_name TEXT,
                data_indicacao TEXT,
                PRIMARY KEY (server_id, user_id),
                FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
            )
            """)
            
            conn.execute("""
            CREATE TABLE IF NOT EXISTS minha_tabela (
                id INTEGER PRIMARY KEY,
                nome TEXT
            )
            """)
            
            conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_pd_server ON primeira_dama (server_id)
            """)
            
            conn.commit()
            
            # Consulta corrigida para listar tabelas no fallback
            cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table'")
            print("Tabelas existentes no banco de dados (fallback):")
            for row in cursor:
                print(f"- {row[0]}")  # Acessa por √≠ndice (0) em vez de nome
            
            DB_PATH = fallback_db
        except Exception as fallback_error:
            print(f"Erro cr√≠tico ao criar banco de dados: {fallback_error}")
            raise


# ========== FUN√á√ïES AUXILIARES PARA NOVOS COMANDOS ==========

def format_currency(amount):
    """Formata valores monet√°rios"""
    return f"üíµ {amount:,} moedas"  # Corrigido o emoji e formata√ß√£o

async def get_user_data(user_id):
    """
    Obt√©m dados do usu√°rio garantindo:
    - Sempre retorna um dicion√°rio
    - Valores padr√£o seguros
    - Convers√£o expl√≠cita de tipos
    - Tratamento de erros completo
    """
    # Dados padr√£o (garante estrutura mesmo em falhas)
    DEFAULT_DATA = {
        'money': 0,
        'bank': 0,
        'level': 1,
        'last_daily': None,
        'last_rep': None
    }
    
    # Modo de teste (simula√ß√£o)
    if TEST_MODE:
        return {**DEFAULT_DATA, **test_db['users'].get(str(user_id)), }
    
    # Modo produ√ß√£o (banco real)
    try:
        with get_db() as conn:
            # Consulta segura com tratamento de None
            result = conn.execute(
                """SELECT money, bank, level, 
                          last_daily, last_rep 
                   FROM users 
                   WHERE user_id = ?""",
                (user_id,)
            ).fetchone()
            
            if not result:
                return DEFAULT_DATA
                
            # Convers√£o expl√≠cita e segura para dicion√°rio
            if hasattr(result, '_fields'):  # sqlite3.Row
                return {
                    'money': int(result['money']),
                    'bank': int(result['bank']),
                    'level': int(result['level']),
                    'last_daily': result['last_daily'],
                    'last_rep': result['last_rep']
                }
            else:  # Outros formatos (tupla, etc)
                return {
                    'money': int(result[0]),
                    'bank': int(result[1]),
                    'level': int(result[2]),
                    'last_daily': result[3],
                    'last_rep': result[4]
                }
                
    except sqlite3.Error as db_error:
        print(f"üö® Erro no banco de dados: {db_error}")
        return DEFAULT_DATA
    except Exception as general_error:
        print(f"‚ö†Ô∏è Erro inesperado: {general_error}")
        return DEFAULT_DATA
    
# ============= LOCK GLOBAL ABSOLUTO ANTI-DUPLICA√á√ÉO =============
GLOBAL_HELP_LOCK = asyncio.Lock()
ACTIVE_HELP_USERS = set()

@bot.command(name='f')  # COMANDO √öNICO - LOCK GLOBAL
async def help_command(ctx):
    """ANTI-DUPLICA√á√ÉO RADICAL - LOCK GLOBAL"""
    if ctx.author.bot:
        return
    
    user_id = ctx.author.id
    
    # üö´ LOCK GLOBAL ABSOLUTO - IMPOSS√çVEL DUPLICAR
    async with GLOBAL_HELP_LOCK:
        if user_id in ACTIVE_HELP_USERS:
            logger_main.error(f"üö´ RADICAL: DUPLICA√á√ÉO BLOQUEADA para {user_id}")
            return
        ACTIVE_HELP_USERS.add(user_id)
    
    try:
        logger_main.error(f"üéØ RADICAL: COMANDO !f √öNICO para {user_id}")
        
        # Remove qualquer painel existente IMEDIATAMENTE
        async with help_manager._lock:
            if user_id in help_manager.active_panels:
                try:
                    await help_manager.active_panels[user_id].delete()
                    logger_main.error(f"üóëÔ∏è RADICAL: Painel anterior DELETADO para {user_id}")
                except:
                    pass
                del help_manager.active_panels[user_id]
        
        # Cria APENAS UM painel
        message = await help_manager._send_new_panel(ctx)
        
        # Registra no singleton
        async with help_manager._lock:
            help_manager.active_panels[user_id] = message
        
        logger_main.error(f"‚úÖ RADICAL: PAINEL √öNICO CRIADO para {user_id} - Total: {len(help_manager.active_panels)}")
        
    except Exception as e:
        logger_main.error(f"‚ùå RADICAL: ERRO para {user_id}: {e}")
    finally:
        # SEMPRE libera o lock global
        async with GLOBAL_HELP_LOCK:
            ACTIVE_HELP_USERS.discard(user_id)
        logger_main.error(f"üîì RADICAL: Lock liberado para {user_id}")

# ================= CONFIGURA√á√ÉO PRINCIPAL =================
LOG_CHANNEL_ID = 1388002478921879582
VOICE_COUNTER_CHANNEL_ID = 1388002478921879582

# ================= SISTEMA DE LOGS =================
async def registrar_log(comando: str, autor: discord.Member, alvo=None, motivo=None):
    """Registra a√ß√µes no canal de logs"""
    try:
        log_channel = bot.get_channel(LOG_CHANNEL_ID)
        if not log_channel:
            print("‚ö†Ô∏è Canal de log n√£o encontrado!")
            return

        embed = discord.Embed(
            title=f"üìù {comando.title()}",
            color=0x3498db,
            timestamp=datetime.now(timezone.utc)
        )
        embed.add_field(name="Autor", value=f"{autor.mention} ({autor.id})", inline=False)
        
        if alvo:
            embed.add_field(name="Alvo", value=f"{alvo.mention} ({alvo.id})", inline=False)
        if motivo:
            embed.add_field(name="Motivo", value=motivo, inline=False)
            
        await log_channel.send(embed=embed)
    except Exception as e:
        print(f"Erro ao registrar log: {e}")

# ================= TRATAMENTO DE ERROS OTIMIZADO =================
@bot.event
async def on_command_error(ctx, error):
    """Sistema robusto de tratamento de erros"""
    
    # Erros ignorados silenciosamente
    ignored_errors = (commands.CommandNotFound, commands.DisabledCommand)
    if isinstance(error, ignored_errors):
        return
    
    # Erros de permiss√£o
    elif isinstance(error, commands.MissingPermissions):
        perms = ', '.join([p.replace('_', ' ').title() for p in error.missing_permissions])
        await ctx.send(f"‚ùå **Sem permiss√£o!** Voc√™ precisa de: `{perms}`", delete_after=10)
    
    elif isinstance(error, commands.BotMissingPermissions):
        perms = ', '.join([p.replace('_', ' ').title() for p in error.missing_permissions])
        await ctx.send(f"‚ùå **Bot sem permiss√£o!** Preciso de: `{perms}`", delete_after=10)
    
    # Erros de argumentos
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send(f"‚ùå **Argumento faltando:** `{error.param.name}`. Use `!ajuda` para detalhes.", delete_after=10)
    
    elif isinstance(error, commands.BadArgument):
        await ctx.send(f"‚ùå **Argumento inv√°lido!** Verifique o formato e tente novamente.", delete_after=10)
    
    elif isinstance(error, (commands.MemberNotFound, commands.UserNotFound)):
        await ctx.send("‚ùå **Usu√°rio n√£o encontrado!** Verifique se mencionou corretamente.", delete_after=10)
    
    elif isinstance(error, commands.RoleNotFound):
        await ctx.send("‚ùå **Cargo n√£o encontrado!** Verifique o nome do cargo.", delete_after=10)
    
    elif isinstance(error, commands.ChannelNotFound):
        await ctx.send("‚ùå **Canal n√£o encontrado!** Verifique se o canal existe.", delete_after=10)
    
    # Cooldown
    elif isinstance(error, commands.CommandOnCooldown):
        remaining = int(error.retry_after)
        time_format = f"{remaining}s" if remaining < 60 else f"{remaining//60}m {remaining%60}s"
        await ctx.send(f"‚è≥ **Calma a√≠!** Aguarde {time_format} para usar `!{ctx.command}` novamente.", delete_after=min(15, remaining))
    
    # Erros de contexto
    elif isinstance(error, commands.NoPrivateMessage):
        await ctx.send("‚ùå **Este comando s√≥ funciona em servidores!**", delete_after=10)
    
    elif isinstance(error, commands.PrivateMessageOnly):
        await ctx.send("‚ùå **Este comando s√≥ funciona em DM!**", delete_after=10)
    
    # Erros HTTP do Discord
    elif isinstance(error, discord.HTTPException):
        if error.status == 429:
            await ctx.send("‚è≥ **Rate limit ativado!** Tente novamente em alguns segundos.", delete_after=15)
        elif error.status == 403:
            await ctx.send("‚ùå **Sem permiss√£o para executar esta a√ß√£o!**", delete_after=10)
        elif error.status == 404:
            await ctx.send("‚ùå **Recurso n√£o encontrado!** Pode ter sido deletado.", delete_after=10)
        else:
            logging.error(f"HTTP Exception {error.status}: {error}")
            await ctx.send("‚ö†Ô∏è **Erro de conex√£o.** Tente novamente.", delete_after=10)
    
    # PROTE√á√ÉO ESPECIAL para CommandInvokeError com UnboundLocalError
    elif isinstance(error, commands.CommandInvokeError):
        original_error = error.original
        
        # Tratamento espec√≠fico para UnboundLocalError
        if isinstance(original_error, UnboundLocalError):
            logger_main.critical(f"üö® ERRO CR√çTICO: UnboundLocalError no comando {ctx.command} por {ctx.author}")
            logger_main.critical(f"Vari√°vel n√£o definida: {str(original_error)}")
            logger_main.critical(f"Stack trace: {error}")
            logger_main.critical(f"‚ö†Ô∏è ATEN√á√ÉO: Este erro deveria ter sido resolvido com a corre√ß√£o do like_button. Se ainda aparecer, h√° outro problema!")
            
            # For√ßa limpeza do sistema de ajuda se necess√°rio
            if ctx.command and ctx.command.name in ['lajuda', 'lf', 'f']:
                try:
                    async with help_manager._lock:
                        help_manager.processing_users.discard(ctx.author.id if ctx else None)
                    logger_main.info("üîß Sistema de ajuda for√ßadamente resetado devido a UnboundLocalError")
                except Exception as cleanup_error:
                    logger_main.error(f"Erro na limpeza for√ßada: {cleanup_error}")
            
            if await bot.is_owner(ctx.author):
                await ctx.send(f"üö® **ERRO CR√çTICO UnboundLocalError:** `{str(original_error)}`\nüí° Sistema resetado automaticamente.", delete_after=30)
            else:
                await ctx.send("‚ùå **Erro interno detectado.** O sistema foi resetado automaticamente. Tente novamente em alguns segundos.", delete_after=15)
            return
        
        # Outros CommandInvokeError
        logging.error(f"CommandInvokeError em {ctx.command}: {type(original_error).__name__}: {original_error}")
        if await bot.is_owner(ctx.author):
            await ctx.send(f"üîß **Debug Info:** `{type(original_error).__name__}: {str(original_error)[:100]}`", delete_after=20)
        else:
            await ctx.send("‚ö†Ô∏è **Erro inesperado.** O erro foi registrado para an√°lise.", delete_after=10)
    
    # Erros cr√≠ticos/inesperados
    else:
        # Log detalhado para depura√ß√£o
        logging.error(f"Erro n√£o tratado em {ctx.command}: {type(error).__name__}: {error}")
        
        # Debug info para desenvolvedores
        if await bot.is_owner(ctx.author):
            await ctx.send(f"üîß **Debug Info:** `{type(error).__name__}: {str(error)[:100]}`", delete_after=20)
        else:
            await ctx.send("‚ö†Ô∏è **Erro inesperado.** O erro foi registrado para an√°lise.", delete_after=10)
    
    # Limpa mensagens de erro antigas (opcional)
    try:
        async for message in ctx.channel.history(limit=3, before=ctx.message):
            if (message.author == bot.user and 
                any(message.content.startswith(prefix) for prefix in ['‚ùå', '‚è≥', '‚ö†Ô∏è']) and
                (datetime.now(timezone.utc) - message.created_at).seconds < 30):
                await message.delete()
                break
    except:
        pass

# ================= COMANDO CARTEIRA ATUALIZADO =================
@bot.command(name='carteira')
@commands.cooldown(1, 5, BucketType.user)
async def carteira(ctx, member: discord.Member = None):
    """Mostra saldo com prote√ß√£o contra duplica√ß√£o"""
    # Verifica√ß√£o inicial
    if ctx.author.bot:
        return
    
    member = member or ctx.author
    
    # Sistema duplo de preven√ß√£o:
    # 1. Limpa mensagens anteriores do bot para este usu√°rio
    async for msg in ctx.channel.history(limit=10):
        if msg.author == bot.user and msg.embeds and f"Carteira de {member.display_name}" in msg.embeds[0].title:
            try:
                await msg.delete()
            except:
                pass
    
    # 2. Limpa atrav√©s do sistema LAST_WALLET_MESSAGES (se ainda existir)
    try:
        if ctx.author.id in LAST_WALLET_MESSAGES:
            old_msg = LAST_WALLET_MESSAGES[ctx.author.id]
            await old_msg.delete()
    except:
        pass
    
    try:
        user_data = await get_user_data(member.id)
        
        money = int(user_data.get('money', 0))
        bank = int(user_data.get('bank', 0))
        total = money + bank
        
        embed = discord.Embed(
            title=f"üí∞ Carteira de {member.display_name}",
            color=0x00ff00
        )
        embed.add_field(name="üíµ Carteira", value=f"{money:,} moedas", inline=True)
        embed.add_field(name="üè¶ Banco", value=f"{bank:,} moedas", inline=True)
        embed.add_field(name="üíé Total", value=f"{total:,} moedas", inline=False)
        
        # Envia a nova mensagem e atualiza o cache
        msg = await ctx.send(embed=embed)
        LAST_WALLET_MESSAGES[ctx.author.id] = msg  # Atualiza o dicion√°rio global
        
        # Auto-delete ap√≥s 30 segundos (opcional)
        await asyncio.sleep(30)
        try:
            await msg.delete()
            await ctx.message.delete()
        except:
            pass
            
    except Exception as e:
        print(f"Erro no comando carteira: {e}")
        error_msg = await ctx.send("‚ö†Ô∏è Ocorreu um erro ao acessar os dados financeiros.", delete_after=10)
        await asyncio.sleep(10)
        try:
            await error_msg.delete()
        except:
            pass

# ================= SISTEMA DE XP/N√çVEIS =================
@bot.listen('on_message')
async def on_message_listener(message):
    """Escuta mensagens para o sistema de XP (n√£o processa comandos duplicados)"""
    if message.author == bot.user:  # Ignora mensagens do pr√≥prio bot
        return

    # Se a mensagem come√ßa com o prefixo (!), deixa o Discord.py processar o comando normalmente
    if message.content.startswith(bot.command_prefix):
        return

    # Sistema de XP (apenas para mensagens normais, n√£o comandos)
    if TEST_MODE:
        user_id = str(message.author.id)
        if user_id not in test_db['users']:
            test_db['users'][user_id] = {
                'xp': 10,
                'level': 1,
                'money': 0,
                'rep': 0
            }
        else:
            test_db['users'][user_id]['xp'] += 5
        
        xp = test_db['users'][user_id]['xp']
        level = test_db['users'][user_id]['level']
        xp_needed = level * 100
        
        if xp >= xp_needed:
            test_db['users'][user_id]['level'] += 1
            test_db['users'][user_id]['xp'] -= xp_needed
            await message.channel.send(f"üéâ {message.author.mention} subiu para o n√≠vel {level + 1}!")
    else:
        with get_db() as conn:
            user = conn.execute(
                "SELECT * FROM users WHERE user_id = ?", 
                (message.author.id,)
            ).fetchone()
            
            if not user:
                conn.execute(
                    "INSERT INTO users (user_id, xp, level, money) VALUES (?, ?, ?, ?)",
                    (message.author.id, 10, 1, 0)
                )
                xp = 10
                level = 1
            else:
                conn.execute(
                    "UPDATE users SET xp = xp + 5 WHERE user_id = ?",
                    (message.author.id,)
                )
                xp = user['xp'] + 5
                level = user['level']
            
            xp_needed = level * 100
            if xp >= xp_needed:
                conn.execute(
                    "UPDATE users SET level = level + 1, xp = xp - ? WHERE user_id = ?",
                    (xp_needed, message.author.id)
                )
                await message.channel.send(f"üéâ {message.author.mention} subiu para o n√≠vel {level + 1}!")
            
            conn.commit()

# ================= COMANDOS DE APAR√äNCIA =================
@bot.command(name='andar')
@commands.is_owner()
async def andar(ctx, *, status: str):
    """Altera o status 'Jogando' do bot (apenas dono)"""
    try:
        await bot.change_presence(activity=discord.Game(name=status))
        await ctx.send(f"‚úÖ Status alterado para: **{status}**")
        await registrar_log("alterar_status", ctx.author, motivo=f"Novo status: {status}")
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao alterar status: {e}")

@bot.command(name='setavatar')
@commands.is_owner()
async def set_avatar(ctx, url: str):
    """Altera o avatar do bot via URL (apenas dono)"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    await bot.user.edit(avatar=await response.read())
                    await ctx.send("‚úÖ Avatar atualizado!")
                    await registrar_log("alterar_avatar", ctx.author)
                else:
                    await ctx.send("‚ùå URL inv√°lida ou imagem n√£o acess√≠vel")
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao atualizar avatar: {e}")

@bot.command(name='setbanner')
@commands.is_owner()
async def set_banner(ctx, url: str):
    """Altera o banner do bot (requer conta premium)"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    await bot.user.edit(banner=await response.read())
                    await ctx.send("‚úÖ Banner atualizado!")
                    await registrar_log("alterar_banner", ctx.author)
                else:
                    await ctx.send("‚ùå URL inv√°lida ou imagem n√£o acess√≠vel")
    except discord.HTTPException:
        await ctx.send("‚ùå Seu bot precisa ter **Nitro** para alterar o banner!")
    except Exception as e:
        await ctx.send(f"‚ùå Erro desconhecido: {e}")

@bot.command(name='setusername')
@commands.is_owner()
async def set_username(ctx, *, nome: str):
    """Altera o nome de usu√°rio do bot (apenas dono)"""
    try:
        if len(nome) < 2 or len(nome) > 32:
            await ctx.send("‚ùå O nome deve ter entre 2 e 32 caracteres!")
            return
            
        await bot.user.edit(username=nome)
        await ctx.send(f"‚úÖ Nome alterado para: **{nome}**")
        await registrar_log("alterar_username", ctx.author, motivo=f"Novo nome: {nome}")
    except discord.HTTPException as e:
        if "TOO_MANY_USERNAME_CHANGES" in str(e):
            await ctx.send("‚ùå Voc√™ s√≥ pode alterar o nome **2 vezes por hora**!")
        else:
            await ctx.send(f"‚ùå Erro ao alterar nome: {e}")
    except Exception as e:
        await ctx.send(f"‚ùå Erro desconhecido: {e}")


# ================= MENU INTERATIVO DE AJUDA =================
# ===== SISTEMA ANTIGO COMPLETAMENTE REMOVIDO =====
# TODO O SISTEMA ANTERIOR FOI ELIMINADO PARA EVITAR DUPLICA√á√ÉO

# ================= COMANDOS FALTANTES =================

@bot.command(name='tempo')
async def tempo_membro(ctx, member: discord.Member = None):
    """Mostra h√° quanto tempo o membro est√° no servidor"""
    member = member or ctx.author
    join_date = member.joined_at
    
    embed = discord.Embed(
        title=f"‚è±Ô∏è Tempo no servidor - {member.display_name}",
        description=f"{member.mention} est√° aqui desde {join_date.strftime('%d/%m/%Y')}",
        color=0x00ff00
    )
    embed.add_field(name="Total no servidor", value=f"{(datetime.now(timezone.utc) - join_date).days} dias", inline=True)
    await ctx.send(embed=embed)

@bot.command(name='addvip')
@commands.has_permissions(administrator=True)
async def add_vip(ctx, member: discord.Member, level: int = 1):
    """Adiciona status VIP a um membro"""
    if level < 1 or level > 5:
        return await ctx.send("‚ùå N√≠vel VIP deve ser entre 1 e 5")
    
    if TEST_MODE:
        user_id = str(member.id)
        if user_id not in test_db['users']:
            test_db['users'][user_id] = {}
        test_db['users'][user_id]['vip_level'] = level
    else:
        with get_db() as conn:
            conn.execute(
                "UPDATE users SET vip_level = ? WHERE user_id = ?",
                (level, member.id)
            )
            conn.commit()
    
    await ctx.send(f"‚úÖ {member.mention} agora √© VIP n√≠vel {level}!")

@bot.command(name='addvipc')
@commands.has_permissions(administrator=True)
async def add_vip_with_role(ctx, member: discord.Member, role: discord.Role, level: int = 1):
    """Adiciona VIP com cargo personalizado"""
    await add_vip(ctx, member, level)
    await member.add_roles(role)
    await ctx.send(f"‚úÖ Cargo {role.name} adicionado!")

@bot.command(name='removevipc')
@commands.has_permissions(administrator=True)
async def remove_vip_with_role(ctx, member: discord.Member, role: discord.Role):
    """Remove VIP e cargo"""
    if TEST_MODE:
        user_id = str(member.id)
        if user_id in test_db['users']:
            test_db['users'][user_id]['vip_level'] = 0
    else:
        with get_db() as conn:
            conn.execute(
                "UPDATE users SET vip_level = 0 WHERE user_id = ?",
                (member.id,)
            )
            conn.commit()
    
    await member.remove_roles(role)
    await ctx.send(f"‚úÖ Status VIP e cargo {role.name} removidos de {member.mention}!")

@bot.command(name='familia')
@commands.has_permissions(administrator=True)
async def criar_familia(ctx, *, nome: str):
    """Cria uma fam√≠lia VIP"""
    if TEST_MODE:
        family_id = len(test_db['families']) + 1
        test_db['families'].append({
            'family_id': family_id,
            'name': nome,
            'leader_id': ctx.author.id,
            'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        })
    else:
        with get_db() as conn:
            conn.execute(
                "INSERT INTO families (name, leader_id, created_at) VALUES (?, ?, ?)",
                (nome, ctx.author.id, datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            )
            conn.commit()
    
    await ctx.send(f"‚úÖ Fam√≠lia '{nome}' criada com sucesso!")

@bot.command(name='addfamily')
@commands.has_permissions(administrator=True)
async def add_family_member(ctx, member: discord.Member, family_name: str):
    """Adiciona membro √† fam√≠lia"""
    if TEST_MODE:
        family = next((f for f in test_db['families'] if f['name'].lower() == family_name.lower()), None)
        if not family:
            return await ctx.send("‚ùå Fam√≠lia n√£o encontrada!")
        
        user_id = str(member.id)
        if user_id not in test_db['users']:
            test_db['users'][user_id] = {}
        test_db['users'][user_id]['family_id'] = family['family_id']
    else:
        with get_db() as conn:
            family = conn.execute(
                "SELECT family_id FROM families WHERE LOWER(name) = LOWER(?)",
                (family_name,)
            ).fetchone()
            
            if not family:
                return await ctx.send("‚ùå Fam√≠lia n√£o encontrada!")
            
            conn.execute(
                "UPDATE users SET family_id = ? WHERE user_id = ?",
                (family['family_id'], member.id)
            )
            conn.commit()
    
    await ctx.send(f"‚úÖ {member.mention} foi adicionado √† fam√≠lia '{family_name}'!")

@bot.command(name='removefamily')
@commands.has_permissions(administrator=True)
async def remove_family_member(ctx, member: discord.Member):
    """Remove membro de fam√≠lia"""
    if TEST_MODE:
        user_id = str(member.id)
        if user_id in test_db['users']:
            test_db['users'][user_id]['family_id'] = None
    else:
        with get_db() as conn:
            conn.execute(
                "UPDATE users SET family_id = NULL WHERE user_id = ?",
                (member.id,)
            )
            conn.commit()
    
    await ctx.send(f"‚úÖ {member.mention} foi removido de sua fam√≠lia!")

@bot.command(name='register')
@commands.has_permissions(manage_roles=True)
async def register_member(ctx, member: discord.Member):
    """Registra um novo membro no servidor"""
    # Aqui voc√™ pode adicionar l√≥gica para atribuir cargos iniciais
    await update_staff_points(ctx.author.id, 'registers')
    await ctx.send(f"‚úÖ {member.mention} foi registrado por {ctx.author.mention}!")

@bot.command(name='verificar')
@commands.has_permissions(manage_roles=True)
async def verificar_membro(ctx, member: discord.Member):
    """Verifica a identidade de um membro"""
    await update_staff_points(ctx.author.id, 'verifications')
    await ctx.send(f"‚úÖ {member.mention} foi verificado por {ctx.author.mention}!")           

# ================= VERIFICADOR DE COMANDOS =================
def verificar_comandos():
    """Verifica se todos os comandos essenciais est√£o registrados e configurados corretamente"""
    problemas = []
    comandos_verificados = 0
    
    comandos_essenciais = [
        'lajuda', 'lf', 'f', 'lmute', 'lumpute', 'lban', 'ldesban',
        'linfo', 'lserverinfo', 'ban', 'desban', 'mute', 'unmute', 'nick', 'cl',
        'andar', 'setavatar', 'setbanner', 'setusername', 'empregos', 'trabalhar',
        'addrole', 'removerole', 'advertence', 'removeadvertence', 'mutecall',
        'unmutecall', 'unbanall', 'tempo', 'addvipc', 'removevipc', 'removefamily',
        'carteira', 'daily', 'depositar', 'avatar', 'rep', 'addvip', 'familia',
        'register', 'verificar', 'membersrole'
    ]
    
    comandos_com_permissao = [
        'lban', 'ldesban', 'lmute', 'lumpute', 'ban', 'desban', 'mute', 'unmute',
        'nick', 'cl', 'addrole', 'removerole', 'removeadvertence', 'mutecall',
        'unmutecall', 'unbanall', 'addvipc', 'removevipc', 'removefamily',
        'addvip', 'familia', 'register', 'verificar'
    ]
    
    # Verifica comandos faltantes
    for cmd in comandos_essenciais:
        if not bot.get_command(cmd):
            problemas.append(f"- [ ] `!{cmd}`: Comando n√£o registrado")

    # Verifica cada comando existente
    for comando in bot.commands:
        if comando.name not in comandos_essenciais:
            continue
            
        comandos_verificados += 1
        
        if comando.name in comandos_com_permissao:
            has_check = any(
                hasattr(check, '__commands_checks__') or 
                'has_permission' in str(check)
                for check in comando.checks
            )
            
            if not has_check:
                problemas.append(f"- [ ] `!{comando.name}`: Sem verifica√ß√£o de permiss√µes adequadas")

    # Exibe relat√≥rio
    print("\n" + "="*40)
    print(f"VERIFICA√á√ÉO DE COMANDOS ({comandos_verificados} comandos analisados)")
    print("="*40)
    
    if problemas:
        for problema in problemas:
            print(problema)
        print(f"\n{len(problemas)} problema(s) encontrado(s)!")
    else:
        print("‚úÖ Todos os comandos est√£o configurados corretamente")
    print("="*40 + "\n")
    
    return len(problemas) == 0

# ================= VERIFICA√á√ÉO PERI√ìDICA =================
@tasks.loop(hours=24)
async def verificar_periodicamente():
    """Verifica os comandos do bot periodicamente"""
    print("\nüîç Executando verifica√ß√£o peri√≥dica de comandos...")
    verificar_comandos()

# ================= COMANDO CL =================
@bot.command(name='cl')
@commands.has_permissions(manage_messages=True)
async def limpar(ctx, limite: int = 50):
    """Limpa mensagens do chat (padr√£o: 50 mensagens)"""
    try:
        # Valida√ß√£o de entrada
        if limite <= 0:
            await ctx.send("‚ùå O n√∫mero deve ser maior que 0!", delete_after=5)
            return
            
        if limite > 100:
            await ctx.send("‚ö†Ô∏è O limite m√°ximo √© de 100 mensagens por vez!", delete_after=5)
            return
        
        # Verifica permiss√µes do bot
        if not ctx.guild.me.guild_permissions.manage_messages:
            await ctx.send("‚ùå Eu n√£o tenho permiss√£o para gerenciar mensagens!", delete_after=10)
            return
            
        # Executa limpeza
        deleted = await ctx.channel.purge(limit=limite+1, check=lambda m: True)
        
        if deleted:
            # Mensagem de sucesso (auto-deleta em 5 segundos)
            success_msg = await ctx.send(f"üßπ **{len(deleted)-1} mensagens** foram limpas com sucesso!", delete_after=5)
            await registrar_log("limpeza de mensagens", ctx.author, motivo=f"{len(deleted)-1} mensagens removidas")
        else:
            await ctx.send("‚ÑπÔ∏è Nenhuma mensagem foi encontrada para limpar.", delete_after=5)
            
    except discord.Forbidden:
        await ctx.send("‚ùå **Sem permiss√£o!** Preciso da permiss√£o `Gerenciar Mensagens`.", delete_after=10)
    except discord.HTTPException as e:
        if "You can only bulk delete messages" in str(e):
            await ctx.send("‚ùå N√£o posso deletar mensagens com mais de 14 dias!", delete_after=10)
        else:
            await ctx.send(f"‚ùå Erro HTTP: {str(e)[:100]}...", delete_after=10)
    except Exception as e:
        print(f"‚ö†Ô∏è Erro cr√≠tico no comando cl: {type(e).__name__}: {e}")
        # N√£o mostra erro gen√©rico - muito vago
        await ctx.send("‚ùå Ocorreu um erro inesperado. Verifique minhas permiss√µes.", delete_after=10)

# ================= CONTADOR DE VOZ =================
@tasks.loop(minutes=1)
async def update_voice_counter():
    """Atualiza o nome do canal de voz com a contagem de membros em chamadas"""
    try:
        guild = bot.guilds[0]
        voice_channel = bot.get_channel(VOICE_COUNTER_CHANNEL_ID)
        
        if voice_channel:
            members_in_voice = sum(len(channel.members) for channel in guild.voice_channels)
            new_name = f"üéôÔ∏è Em call: {members_in_voice}"
            
            if voice_channel.name != new_name:
                await voice_channel.edit(name=new_name)
    except Exception as e:
        print(f"Erro ao atualizar contador de voz: {e}")

# ================= COMANDOS DE INFORMA√á√ÉO =================
@bot.command(name='linfo')
async def linfo(ctx):
    """Mostra informa√ß√µes sobre o bot"""
    embed = discord.Embed(
        title="ü§ñ Informa√ß√µes do Bot",
        color=0x00ff00,
        description="Bot de modera√ß√£o para gerenciamento de servidores Discord"
    )
    
    embed.add_field(name="üìÖ Criado em", value=bot.user.created_at.strftime("%d/%m/%Y"), inline=True)
    embed.add_field(name="‚öôÔ∏è Vers√£o", value="1.0", inline=True)
    embed.add_field(name="üìö Comandos", value=f"{len(bot.commands)} comandos dispon√≠veis", inline=True)
    embed.add_field(name="üåê Servidores", value=f"Presente em {len(bot.guilds)} servidores", inline=True)
    embed.add_field(name="‚è±Ô∏è Lat√™ncia", value=f"{round(bot.latency * 1000)}ms", inline=True)
    embed.add_field(name="üõ†Ô∏è Desenvolvedor", value="[SeuNome]", inline=True)
    embed.add_field(name="üìù Prefixo", value="`!`", inline=True)
    embed.add_field(name="‚ùì Ajuda", value="Use `!f` para ver todos os comandos", inline=False)
    embed.add_field(name="üõ†Ô∏è Sistema", value="SQLite + Cache Otimizado", inline=True)
    embed.add_field(name="üîÑ Uptime", value="24/7 Online", inline=True)
    
    embed.set_thumbnail(url=bot.user.avatar.url)
    embed.set_footer(text=f"Solicitado por {ctx.author.display_name}", icon_url=ctx.author.avatar.url)
    
    await ctx.send(embed=embed)

@bot.command(name='lserverinfo', aliases=['lserver'])
async def lserverinfo(ctx):
    """Mostra informa√ß√µes detalhadas do servidor"""
    guild = ctx.guild
    
    embed = discord.Embed(
        title=f"üìä Informa√ß√µes do Servidor - {guild.name}",
        color=0x7289da,
        description=guild.description if guild.description else "Sem descri√ß√£o"
    )
    
    embed.add_field(name="üëë Dono", value=guild.owner.mention, inline=True)
    embed.add_field(name="üÜî ID", value=guild.id, inline=True)
    embed.add_field(name="üìÖ Criado em", value=guild.created_at.strftime("%d/%m/%Y"), inline=True)
    embed.add_field(name="üë• Membros", value=guild.member_count, inline=True)
    embed.add_field(name="üí¨ Canais", value=f"{len(guild.text_channels)} texto | {len(guild.voice_channels)} voz", inline=True)
    embed.add_field(name="üòé Emojis", value=len(guild.emojis), inline=True)
    embed.add_field(name="üöÄ N√≠vel de Boost", value=f"N√≠vel {guild.premium_tier}", inline=True)
    embed.add_field(name="‚ú® Boosts", value=guild.premium_subscription_count, inline=True)
    embed.add_field(name="üîê Verifica√ß√£o", value=str(guild.verification_level).title(), inline=True)
    
    if guild.icon:
        embed.set_thumbnail(url=guild.icon.url)
    if guild.banner:
        embed.set_image(url=guild.banner.url)
    
    embed.set_footer(text=f"Solicitado por {ctx.author.display_name}", icon_url=ctx.author.avatar.url)
    
    await ctx.send(embed=embed)

# ================= COMANDO AJUDA ROBUSTO =================
# Sistema completamente reescrito sem bugs de duplica√ß√£o
# Vari√°veis antigas removidas - agora usa HelpPanelManager singleton

# Fun√ß√µes antigas removidas - o HelpPanelManager singleton gerencia tudo

# ================= SISTEMA DE AJUDA PROFISSIONAL - SOLU√á√ÉO DEFINITIVA =================
class HelpPanelManager:
    """
    Gerenciador singleton profissional para pain√©is de ajuda
    Implementa pattern Singleton + Circuit Breaker para eliminar duplica√ß√£o
    """
    _instance = None
    _lock = asyncio.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if not getattr(self, '_initialized', False):
            self.active_panels = {}  # user_id -> message
            self.processing_users = set()  # users currently processing
            self.last_request = {}  # user_id -> timestamp
            self.circuit_breaker_delay = 2.0  # 2 seconds between requests
            self._initialized = True
    
    async def can_create_panel(self, user_id):
        """Verifica se o usu√°rio pode criar um novo painel"""
        current_time = time.time()
        
        # Circuit Breaker: verifica se passou tempo suficiente
        if user_id in self.last_request:
            time_diff = current_time - self.last_request[user_id]
            if time_diff < self.circuit_breaker_delay:
                return False, f"Aguarde {self.circuit_breaker_delay - time_diff:.1f}s"
        
        # Verifica se j√° est√° processando
        if user_id in self.processing_users:
            return False, "J√° processando"
        
        return True, "OK"
    
    async def create_panel(self, ctx, logger):
        """Cria um painel de ajuda garantindo unicidade absoluta"""
        user_id = ctx.author.id
        
        logger.info(f"üéØ SINGLETON: Solicita√ß√£o de painel para {user_id}")
        
        async with self._lock:
            # Verifica√ß√£o final dentro do lock
            can_create, reason = await self.can_create_panel(user_id)
            if not can_create:
                logger.debug(f"‚ùå SINGLETON: Painel negado para {user_id}: {reason}")
                return False
            
            # Marca como processando
            self.processing_users.add(user_id)
            self.last_request[user_id] = time.time()
            logger.debug(f"üîí SINGLETON: Usu√°rio {user_id} adquiriu lock")
        
        try:
            # Remove painel anterior se existir
            await self._cleanup_existing_panel(user_id, logger)
            
            # Cria novo painel
            message = await self._send_new_panel(ctx)
            
            # Registra o novo painel
            async with self._lock:
                self.active_panels[user_id] = message
            
            logger.info(f"‚úÖ SINGLETON: Painel criado para {user_id} - Total ativo: {len(self.active_panels)}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå SINGLETON: Erro ao criar painel para {user_id}: {e}")
            return False
        finally:
            # Sempre remove do processamento
            async with self._lock:
                self.processing_users.discard(user_id)
                logger.debug(f"üîì SINGLETON: Usu√°rio {user_id} liberou lock")
    
    async def _cleanup_existing_panel(self, user_id, logger):
        """Remove painel existente do usu√°rio"""
        async with self._lock:
            if user_id in self.active_panels:
                old_panel = self.active_panels[user_id]
                try:
                    await old_panel.delete()
                    logger.debug(f"üóëÔ∏è Painel anterior deletado para {user_id}")
                except discord.NotFound:
                    pass  # J√° foi deletado
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erro ao deletar painel anterior: {e}")
                finally:
                    del self.active_panels[user_id]
    
    async def _send_new_panel(self, ctx):
        """Envia o painel de ajuda"""
        data_hora = datetime.now().strftime('%d/%m/%Y %H:%M')
        
        embed = discord.Embed(
            title="üéÆ PAINEL DE AJUDA FOLK APP",
            description="**Selecione uma categoria no menu abaixo:**",
            color=0x5A67D8
        )
        embed.add_field(
            name="üìã Categorias Dispon√≠veis:",
            value=(
                "```\n"
                "Categoria    Descri√ß√£o\n"
                "‚ÑπÔ∏è  Informa√ß√£o  ‚Üí Comandos informativos\n"
                "üõ°Ô∏è  Modera√ß√£o  ‚Üí Comandos de modera√ß√£o\n" 
                "üéâ  Divers√£o   ‚Üí Comandos de entretenimento\n"
                "‚öôÔ∏è  Utilidade  ‚Üí Ferramentas √∫teis\n"
                "üí∞  Economia   ‚Üí Sistema econ√¥mico\n"
                "üåü  VIP        ‚Üí Comandos exclusivos VIP\n"
                "üëë  PrimDama   ‚Üí Comandos da Primeira Dama\n"
                "```"
            ),
            inline=False
        )
        embed.set_footer(text=f"FOLK APP ‚Ä¢ {data_hora}")
        
        # Envia apenas o embed (sem view problem√°tica)
        message = await ctx.send(embed=embed)
        return message
    
    async def cleanup_expired_panels(self, logger, max_age_seconds=300):
        """Limpa pain√©is expirados (padr√£o: 5 minutos)"""
        current_time = datetime.now()
        expired_users = []
        
        async with self._lock:
            for user_id, message in list(self.active_panels.items()):
                try:
                    # Calcula idade do painel
                    message_time = message.created_at
                    if hasattr(message_time, 'replace'):
                        message_time = message_time.replace(tzinfo=None)
                    
                    age = (current_time - message_time).total_seconds()
                    logger.debug(f"üîç Painel {user_id}: idade {age:.1f}s (max: {max_age_seconds}s)")
                    
                    if age > max_age_seconds:
                        expired_users.append(user_id)
                        try:
                            await message.delete()
                            logger.debug(f"üóëÔ∏è Painel expirado deletado para usu√°rio {user_id}")
                        except discord.NotFound:
                            pass  # J√° foi deletado
                        except Exception as e:
                            logger.warning(f"‚ö†Ô∏è Erro ao deletar painel expirado: {e}")
                except Exception as e:
                    # Se n√£o conseguir verificar idade, marca para remo√ß√£o
                    expired_users.append(user_id)
                    logger.warning(f"‚ö†Ô∏è Erro ao verificar idade do painel {user_id}: {e}")
            
            # Remove registros expirados
            for user_id in expired_users:
                self.active_panels.pop(user_id, None)
                self.processing_users.discard(user_id)
        
        if expired_users:
            logger.info(f"üßπ Limpeza autom√°tica: {len(expired_users)} pain√©is expirados removidos")
    
    def get_status(self):
        """Retorna status do sistema para debug"""
        return {
            "active_panels": len(self.active_panels),
            "processing_users": len(self.processing_users),
            "users_with_panels": list(self.active_panels.keys()),
            "users_processing": list(self.processing_users)
        }

# Inst√¢ncia singleton global
help_manager = HelpPanelManager()
# ================= FUN√á√ïES AUXILIARES DO SISTEMA DE AJUDA =================

# ================= FUN√á√ïES AUXILIARES (MANTIDAS PARA COMPATIBILIDADE) =================
# Fun√ß√£o duplicada removida

# Limpeza autom√°tica do sistema (NOVO SISTEMA PROFISSIONAL)
@tasks.loop(minutes=2)
async def help_system_cleanup():
    """Limpeza autom√°tica do sistema de ajuda profissional"""
    try:
        # Verifica se o help_manager existe
        if 'help_manager' not in globals():
            logger_main.warning("‚ö†Ô∏è help_manager n√£o encontrado - pulando limpeza")
            return
        
        # Executa limpeza de pain√©is expirados (5 minutos)
        await help_manager.cleanup_expired_panels(logger_main, max_age_seconds=300)
        
        # Log de status para debug
        status = help_manager.get_status()
        if status['active_panels'] > 0 or status['processing_users'] > 0:
            logger_main.debug(f"üîç Status p√≥s-limpeza: {status['active_panels']} pain√©is, {status['processing_users']} processando")
            
    except AttributeError as e:
        logger_main.error(f"‚ùå M√©todo n√£o encontrado no help_manager: {e}")
    except Exception as e:
        logger_main.error(f"‚ùå Erro inesperado na limpeza autom√°tica: {type(e).__name__}: {e}")
        # Log adicional para debug
        logger_main.debug(f"help_manager type: {type(help_manager) if 'help_manager' in globals() else 'NOT_FOUND'}")

# Inicia a limpeza autom√°tica quando o bot estiver pronto
@help_system_cleanup.before_loop
async def before_help_cleanup():
    await bot.wait_until_ready()

# ================= COMANDOS DE MODERA√á√ÉO =================
@bot.command(name='lmute')
@commands.has_permissions(moderate_members=True)
async def lmute(ctx, member: discord.Member = None, tempo_minutos: int = 60, *, motivo=None):
    """Silencia um membro por um determinado tempo (padr√£o: 60 minutos)"""
    if not member:
        return await ctx.send("‚ùå Voc√™ precisa mencionar um usu√°rio! Exemplo: `!lmute @usu√°rio [tempo] [motivo]`")
    
    try:
        tempo = timedelta(minutes=tempo_minutos)
        await member.timeout(tempo, reason=motivo)
        
        embed = discord.Embed(
            title="üîá Mute",
            description=f"{member.mention} foi mutado por {tempo_minutos} minutos",
            color=0xff9900
        )
        if motivo:
            embed.add_field(name="Motivo", value=motivo, inline=False)
            
        await ctx.send(embed=embed)
        await registrar_log("mute", ctx.author, member, f"{tempo_minutos} minutos | {motivo or 'Sem motivo'}")
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao mutar: {e}")

@bot.command(name='lumpute')
@commands.has_permissions(moderate_members=True)
async def lumpute(ctx, member: discord.Member = None):
    """Remove o mute de um membro"""
    if not member:
        return await ctx.send("‚ùå Voc√™ precisa mencionar um usu√°rio! Exemplo: `!lumpute @usu√°rio`")
        
    try:
        await member.timeout(None)
        await ctx.send(f"‚úÖ {member.mention} foi desmutado por {ctx.author.mention}")
        await registrar_log("unmute", ctx.author, member)
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao desmutar: {e}")

@bot.command(name='lban')
@commands.has_permissions(ban_members=True)
async def lban(ctx, member: discord.Member = None, *, motivo=None):
    """Bane um membro do servidor"""
    if not member:
        return await ctx.send("‚ùå Voc√™ precisa mencionar um usu√°rio! Exemplo: `!lban @usu√°rio [motivo]`")
    
    try:
        await member.ban(reason=motivo)
        embed = discord.Embed(
            title="üî® Banimento",
            description=f"{member.mention} foi banido por {ctx.author.mention}",
            color=0xff0000
        )
        if motivo:
            embed.add_field(name="Motivo", value=motivo, inline=False)
        await ctx.send(embed=embed)
        await registrar_log("ban", ctx.author, member, motivo)
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao banir: {e}")

@bot.command(name='ldesban')
@commands.has_permissions(ban_members=True)
async def ldesban(ctx, user_id: str = None, *, motivo=None):
    """Desbane um usu√°rio usando seu ID"""
    if not user_id:
        return await ctx.send("‚ùå Voc√™ precisa fornecer um ID! Exemplo: `!ldesban 123456789`")
    
    try:
        if user_id.startswith('<@') and user_id.endswith('>'):
            user_id = user_id[2:-1]
            if user_id.startswith('!'):
                user_id = user_id[1:]

        if not user_id.isdigit():
            await ctx.send("‚ùå O ID do usu√°rio deve conter apenas n√∫meros!", delete_after=5)
            return
            
        user_id = int(user_id)
        
        if user_id < 1:
            await ctx.send("‚ùå ID inv√°lido! Forne√ßa um ID de usu√°rio v√°lido.", delete_after=5)
            return

        user = await bot.fetch_user(user_id)
        await ctx.guild.unban(user, reason=motivo)
        
        embed = discord.Embed(
            title="üîì Desbanimento",
            description=f"Usu√°rio {user.mention} (`{user.id}`) foi desbanido por {ctx.author.mention}",
            color=0x00ff00
        )
        if motivo:
            embed.add_field(name="Motivo", value=motivo, inline=False)
            
        await ctx.send(embed=embed)
        await registrar_log("desban", ctx.author, user, motivo)
        
    except discord.NotFound:
        await ctx.send("‚ùå Usu√°rio n√£o encontrado ou n√£o est√° banido.", delete_after=5)
    except discord.Forbidden:
        await ctx.send("‚ùå Eu n√£o tenho permiss√£o para desbanir usu√°rios.", delete_after=5)
    except discord.HTTPException as e:
        await ctx.send(f"‚ùå Erro ao desbanir: {str(e)}", delete_after=5)
    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro inesperado: {str(e)}", delete_after=5)

# ================= COMANDOS COMPATIBILIDADE =================
@bot.command()
@commands.has_permissions(ban_members=True)
async def ban(ctx, member: discord.Member = None, *, motivo=None):
    """Bane um membro do servidor"""
    await lban(ctx, member, motivo=motivo)


@bot.command()
@commands.is_owner()
async def test_pd(ctx):
    """Testa a tabela primeira_dama"""
    with get_db() as conn:
        conn.execute("INSERT OR IGNORE INTO primeira_dama VALUES (?, ?, ?, ?)", 
                   (ctx.guild.id, ctx.author.id, "Teste", "2023-01-01"))
        conn.commit()
        data = conn.execute("SELECT * FROM primeira_dama").fetchall()
    await ctx.send(f"Dados: {data}")    

@bot.command()
@commands.has_permissions(ban_members=True)
async def desban(ctx, user_id: str = None, *, motivo=None):
    """Desbane um usu√°rio usando seu ID"""
    await ldesban(ctx, user_id, motivo=motivo)

@bot.command()
@commands.has_permissions(moderate_members=True)
async def mute(ctx, member: discord.Member = None, tempo_minutos: int = 60, *, motivo=None):
    """Silencia um membro por um determinado tempo (padr√£o: 60 minutos)"""
    await lmute(ctx, member, tempo_minutos, motivo=motivo)

@bot.command()
@commands.has_permissions(moderate_members=True)
async def unmute(ctx, member: discord.Member = None):
    """Remove o mute de um membro"""
    await lumpute(ctx, member)

@bot.command()
@commands.has_permissions(manage_nicknames=True)
async def nick(ctx, member: discord.Member = None, *, novo_nick=None):
    """Altera o apelido de um membro"""
    if not member:
        return await ctx.send("‚ùå Voc√™ precisa mencionar um usu√°rio! Exemplo: `!nick @usu√°rio [apelido]`")
    
    try:
        await member.edit(nick=novo_nick)
        if novo_nick:
            await ctx.send(f"‚úÖ Apelido de {member.mention} alterado para `{novo_nick}`")
        else:
            await ctx.send(f"‚úÖ Apelido de {member.mention} foi resetado")
        await registrar_log("altera√ß√£o de nick", ctx.author, member, f"Novo nick: {novo_nick}")
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao alterar nick: {e}")

# ================= COMANDOS DE ECONOMIA =================
@bot.command(name='empregos')
async def empregos(ctx):
    """Lista os empregos dispon√≠veis"""
    jobs = {
        "üë®‚Äçüç≥ Chef": "Sal√°rio: 50 moedas - Requer n√≠vel 5",
        "üë∑ Construtor": "Sal√°rio: 40 moedas - Requer n√≠vel 3",
        "üë®‚Äçüíª Programador": "Sal√°rio: 70 moedas - Requer n√≠vel 10",
        "üé® Designer": "Sal√°rio: 60 moedas - Requer n√≠vel 7",
        "üë®‚Äçüî¨ Cientista": "Sal√°rio: 80 moedas - Requer n√≠vel 15"
    }
    
    embed = discord.Embed(
        title="üíº Empregos Dispon√≠veis",
        description="Use !trabalhar para escolher um emprego aleat√≥rio",
        color=0x3498db
    )
    
    for job, info in jobs.items():
        embed.add_field(name=job, value=info, inline=False)
    
    await ctx.send(embed=embed)

@bot.command(name='trabalhar')
async def trabalhar(ctx):
    """Escolhe um emprego aleat√≥rio e ganha moedas"""
    if TEST_MODE:
        jobs = {
            "üë®‚Äçüç≥ Chef": {"salary": 50, "xp": 15},
            "üë∑ Construtor": {"salary": 40, "xp": 10}
        }
        job, info = random.choice(list(jobs.items()))
        
        user_id = str(ctx.author.id)
        if user_id not in test_db['users']:
            test_db['users'][user_id] = {'money': 0, 'xp': 0, 'level': 1}
            
        test_db['users'][user_id]['money'] += info['salary']
        test_db['users'][user_id]['xp'] += info['xp']
        
        embed = discord.Embed(
            title="üíº Trabalho conclu√≠do!",
            description=f"Voc√™ trabalhou como **{job}** e ganhou:\n"
                       f"üí∞ {info['salary']} moedas\n"
                       f"‚ú® {info['xp']} XP",
            color=0x3498db
        )
        await ctx.send(embed=embed)
        await registrar_log("trabalhar", ctx.author, motivo=f"Emprego: {job}, Ganhou: {info['salary']} moedas e {info['xp']} XP")
    else:
        jobs = {
            "üë®‚Äçüç≥ Chef": {"salary": 50, "xp": 15, "required_level": 5},
            "üë∑ Construtor": {"salary": 40, "xp": 10, "required_level": 3},
            "üë®‚Äçüíª Programador": {"salary": 70, "xp": 20, "required_level": 10},
            "üé® Designer": {"salary": 60, "xp": 15, "required_level": 7},
            "üë®‚Äçüî¨ Cientista": {"salary": 80, "xp": 25, "required_level": 15}
        }
        
        with get_db() as conn:
            user = conn.execute(
                "SELECT level FROM users WHERE user_id = ?",
                (ctx.author.id,)
            ).fetchone()
            
            user_level = user['level'] if user else 1
            
            available_jobs = {job: info for job, info in jobs.items() if user_level >= info["required_level"]}
            
            if not available_jobs:
                return await ctx.send("‚ùå Voc√™ n√£o tem n√≠vel suficiente para nenhum emprego! Suba de n√≠vel e tente novamente.")
            
            job, info = random.choice(list(available_jobs.items()))
            
            conn.execute("""
            INSERT INTO users (user_id, money, xp, level)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(user_id) DO UPDATE SET
                money = money + ?,
                xp = xp + ?
            """, (
                ctx.author.id,
                info["salary"],
                info["xp"],
                user_level,
                info["salary"],
                info["xp"]
            ))
            conn.commit()

        embed = discord.Embed(
            title="üíº Trabalho conclu√≠do!",
            description=f"Voc√™ trabalhou como **{job}** e ganhou:\n"
                       f"üí∞ {info['salary']} moedas\n"
                       f"‚ú® {info['xp']} XP",
            color=0x3498db
        )
        await ctx.send(embed=embed)
        await registrar_log("trabalhar", ctx.author, motivo=f"Emprego: {job}, Ganhou: {info['salary']} moedas e {info['xp']} XP")

# ================= NOVOS COMANDOS DE MODERA√á√ÉO =================
@bot.command(name='warn')
@commands.has_permissions(kick_members=True)
async def warn_user(ctx, member: discord.Member, *, motivo="Sem motivo especificado"):
    """Adiciona uma advert√™ncia a um membro"""
    warn_id = random.randint(1000, 9999)
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    if TEST_MODE:
        test_db['warns'].append({
            'warn_id': warn_id,
            'user_id': member.id,
            'moderator_id': ctx.author.id,
            'reason': motivo,
            'timestamp': timestamp
        })
        warn_count = len([w for w in test_db['warns'] if w['user_id'] == member.id])
    else:
        with get_db() as conn:
            conn.execute(
                "INSERT INTO warns (warn_id, user_id, moderator_id, reason, timestamp) VALUES (?, ?, ?, ?, ?)",
                (warn_id, member.id, ctx.author.id, motivo, timestamp)
            )
            warn_count = conn.execute("SELECT COUNT(*) FROM warns WHERE user_id = ?", (member.id,)).fetchone()[0]
            conn.commit()
    
    embed = discord.Embed(
        title="‚ö†Ô∏è Advert√™ncia Aplicada",
        description=f"{member.mention} recebeu uma advert√™ncia",
        color=0xff9900
    )
    embed.add_field(name="Motivo", value=motivo, inline=False)
    embed.add_field(name="Moderador", value=ctx.author.mention, inline=True)
    embed.add_field(name="Total de Warns", value=f"{warn_count}/3", inline=True)
    embed.add_field(name="ID da Warn", value=warn_id, inline=True)
    
    if warn_count >= 3:
        embed.add_field(name="üî® A√ß√£o Autom√°tica", value="Usu√°rio ser√° banido por ac√∫mulo de advert√™ncias!", inline=False)
        try:
            await member.ban(reason="3 advert√™ncias acumuladas")
            embed.color = 0xff0000
        except:
            embed.add_field(name="‚ö†Ô∏è", value="Erro ao banir automaticamente", inline=False)
    
    await ctx.send(embed=embed)
    await registrar_log("warn", ctx.author, member, f"Motivo: {motivo} | ID: {warn_id}")

@bot.command(name='castigar')
@commands.has_permissions(moderate_members=True)
async def castigar(ctx, member: discord.Member, tempo: int = 60, *, motivo="Comportamento inadequado"):
    """Castiga um membro com timeout tempor√°rio"""
    try:
        timeout_time = timedelta(minutes=tempo)
        await member.timeout(timeout_time, reason=motivo)
        
        embed = discord.Embed(
            title="‚è±Ô∏è Castigo Aplicado",
            description=f"{member.mention} foi castigado por {tempo} minutos",
            color=0xff6600
        )
        embed.add_field(name="Motivo", value=motivo, inline=False)
        embed.add_field(name="Moderador", value=ctx.author.mention, inline=True)
        embed.add_field(name="Dura√ß√£o", value=f"{tempo} minutos", inline=True)
        
        await ctx.send(embed=embed)
        await registrar_log("castigar", ctx.author, member, f"Tempo: {tempo}min | Motivo: {motivo}")
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao aplicar castigo: {e}")

@bot.command(name='removecastigo')
@commands.has_permissions(moderate_members=True)
async def removecastigo(ctx, member: discord.Member):
    """Remove o castigo/timeout de um membro"""
    try:
        await member.timeout(None)
        await ctx.send(f"‚úÖ Castigo removido de {member.mention} por {ctx.author.mention}")
        await registrar_log("remove_castigo", ctx.author, member)
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao remover castigo: {e}")

@bot.command(name='lock')
@commands.has_permissions(manage_channels=True)
async def lock_channel(ctx, channel: discord.TextChannel = None):
    """Trava um canal para @everyone"""
    channel = channel or ctx.channel
    overwrite = channel.overwrites_for(ctx.guild.default_role)
    overwrite.send_messages = False
    
    await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)
    await ctx.send(f"üîí Canal {channel.mention} foi travado!")
    await registrar_log("lock_channel", ctx.author, motivo=f"Canal: {channel.name}")

@bot.command(name='unlock')
@commands.has_permissions(manage_channels=True)
async def unlock_channel(ctx, channel: discord.TextChannel = None):
    """Destrava um canal para @everyone"""
    channel = channel or ctx.channel
    overwrite = channel.overwrites_for(ctx.guild.default_role)
    overwrite.send_messages = None
    
    await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)
    await ctx.send(f"üîì Canal {channel.mention} foi destravado!")
    await registrar_log("unlock_channel", ctx.author, motivo=f"Canal: {channel.name}")

@bot.command(name='nuke')
@commands.has_permissions(manage_channels=True)
async def nuke_channel(ctx):
    """Recria o canal atual (apaga todas as mensagens)"""
    channel = ctx.channel
    position = channel.position
    new_channel = await channel.clone()
    await new_channel.edit(position=position)
    await channel.delete()
    
    embed = discord.Embed(
        title="üí• Canal Resetado",
        description=f"Canal foi completamente limpo por {ctx.author.mention}",
        color=0xff0000
    )
    await new_channel.send(embed=embed)
    await registrar_log("nuke_channel", ctx.author, motivo=f"Canal: {channel.name}")

@bot.command(name='bangif')
@commands.has_permissions(ban_members=True)
async def ban_with_gif(ctx, member: discord.Member, *, motivo="Sem motivo especificado"):
    """Bane um membro com GIF dram√°tico"""
    ban_gifs = [
        "https://media.giphy.com/media/3o7aCRloybJlXpNjSU/giphy.gif",
        "https://media.giphy.com/media/l0HlvtIPzPdt2usKs/giphy.gif",
        "https://media.giphy.com/media/3o6Zt4HU9uwXmXSAuI/giphy.gif"
    ]
    
    try:
        await member.ban(reason=motivo)
        
        embed = discord.Embed(
            title="üî® BANIDO COM ESTILO!",
            description=f"{member.mention} foi eliminado do servidor!",
            color=0xff0000
        )
        embed.add_field(name="Motivo", value=motivo, inline=False)
        embed.add_field(name="Moderador", value=ctx.author.mention, inline=True)
        embed.set_image(url=random.choice(ban_gifs))
        
        await ctx.send(embed=embed)
        await registrar_log("ban_gif", ctx.author, member, motivo)
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao banir: {e}")

@bot.command(name='kick')
@commands.has_permissions(kick_members=True)
async def kick_member(ctx, member: discord.Member, *, motivo="Sem motivo especificado"):
    """Expulsa um membro do servidor"""
    try:
        await member.kick(reason=motivo)
        
        embed = discord.Embed(
            title="üë¢ Membro Expulso",
            description=f"{member.mention} foi expulso do servidor",
            color=0xff9900
        )
        embed.add_field(name="Motivo", value=motivo, inline=False)
        embed.add_field(name="Moderador", value=ctx.author.mention, inline=True)
        
        await ctx.send(embed=embed)
        await registrar_log("kick", ctx.author, member, motivo)
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao expulsar: {e}")

# ================= COMANDO DAILY CORRIGIDO =================
@bot.command(name='daily')
@commands.cooldown(1, 86400, commands.BucketType.user)  # 24h de cooldown
async def daily(ctx):
    """Resgata recompensa di√°ria - Executa apenas UMA vez"""
    if ctx.author.bot:  # Ignora se for um bot
        return
    
    # Verifica√ß√£o adicional para evitar duplica√ß√£o
    if hasattr(ctx, '_daily_processed'):
        return
    ctx._daily_processed = True  # Marca como processado

    try:
        # Verifica se j√° resgatou hoje (verifica√ß√£o adicional ao cooldown)
        user_data = await get_user_data(ctx.author.id)
        
        if user_data['last_daily']:
            last_claimed = datetime.strptime(user_data['last_daily'], '%Y-%m-%d %H:%M:%S')
            if (datetime.now() - last_claimed).total_seconds() < 86400:
                return await ctx.send("‚è≥ Voc√™ j√° resgatou sua recompensa di√°ria hoje!", delete_after=10)

        reward = random.randint(100, 500)
        
        if TEST_MODE:
            user_id = str(ctx.author.id)
            test_db['users'][user_id]['money'] = test_db['users'][user_id].get('money', 0) + reward
            test_db['users'][user_id]['last_daily'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        else:
            with get_db() as conn:
                conn.execute(
                    "UPDATE users SET money = money + ?, last_daily = ? WHERE user_id = ?",
                    (reward, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), ctx.author.id)
                )
                conn.commit()
        
        embed = discord.Embed(
            title="üéÅ Recompensa Di√°ria",
            description=f"{ctx.author.mention} resgatou {format_currency(reward)}!",
            color=0x00ff00
        )
        embed.set_footer(text="Volte amanh√£ para outra recompensa!")
        msg = await ctx.send(embed=embed)
        
        # Delete ap√≥s 30 segundos para evitar spam
        await asyncio.sleep(30)
        try:
            await msg.delete()
            await ctx.message.delete()
        except:
            pass
            
    except Exception as e:
        print(f"Erro no daily: {e}")
        await ctx.send("‚ö†Ô∏è Ocorreu um erro ao processar seu daily.", delete_after=10)

# ================= COMANDOS DE ECONOMIA ADICIONAIS =================
@bot.command(name='depositar')
async def depositar(ctx, amount: str):
    """Deposita moedas no banco"""
    user_data = await get_user_data(ctx.author.id)
    
    if amount.lower() == 'all':
        amount = user_data['money']
    else:
        try:
            amount = int(amount)
            if amount <= 0:
                await ctx.send("‚ùå Valor deve ser positivo!")
                return
        except ValueError:
            await ctx.send("‚ùå Use um n√∫mero ou 'all'!")
            return
    
    if amount > user_data['money']:
        await ctx.send("‚ùå Saldo insuficiente!")
        return
    
    if TEST_MODE:
        user_id = str(ctx.author.id)
        test_db['users'][user_id]['money'] -= amount
        test_db['users'][user_id]['bank'] = test_db['users'][user_id].get('bank', 0) + amount
    else:
        with get_db() as conn:
            conn.execute(
                "UPDATE users SET money = money - ?, bank = bank + ? WHERE user_id = ?",
                (amount, amount, ctx.author.id)
            )
            conn.commit()
    
    await ctx.send(f"üè¶ {ctx.author.mention} depositou {format_currency(amount)} no banco!")

# ================= COMANDOS DE MODERA√á√ÉO ADICIONAIS =================
@bot.command(name='addrole')
@commands.has_permissions(manage_roles=True)
async def addrole(ctx, member: discord.Member, role: discord.Role):
    """Adiciona um cargo a um membro"""
    if role.position >= ctx.guild.me.top_role.position:
        return await ctx.send("‚ùå N√£o posso adicionar este cargo (muito alto na hierarquia)!")
    
    await member.add_roles(role)
    await ctx.send(f"‚úÖ Cargo {role.name} adicionado a {member.mention}")
    await registrar_log("add_role", ctx.author, member, f"Cargo: {role.name}")

@bot.command(name='removerole')
@commands.has_permissions(manage_roles=True)
async def removerole(ctx, member: discord.Member, role: discord.Role):
    """Remove um cargo de um membro"""
    if role.position >= ctx.guild.me.top_role.position:
        return await ctx.send("‚ùå N√£o posso remover este cargo (muito alto na hierarquia)!")
    
    await member.remove_roles(role)
    await ctx.send(f"‚úÖ Cargo {role.name} removido de {member.mention}")
    await registrar_log("remove_role", ctx.author, member, f"Cargo: {role.name}")

@bot.command(name='advertence')
async def advertence(ctx, member: discord.Member = None):
    """Mostra as advert√™ncias de um membro"""
    member = member or ctx.author
    if TEST_MODE:
        warns = [w for w in test_db['warns'] if w['user_id'] == member.id]
    else:
        with get_db() as conn:
            warns = conn.execute("SELECT reason, timestamp FROM warns WHERE user_id = ?", (member.id,)).fetchall()
    
    if not warns:
        return await ctx.send(f"‚ÑπÔ∏è {member.mention} n√£o possui advert√™ncias!")
    
    embed = discord.Embed(
        title=f"‚ö†Ô∏è Advert√™ncias de {member.display_name}",
        description=f"Total: {len(warns)}/3",
        color=0xffcc00
    )
    
    for i, warn in enumerate(warns, 1):
        embed.add_field(
            name=f"Advert√™ncia #{i}",
            value=f"Motivo: {warn['reason']}\nData: {warn['timestamp']}",
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.command(name='removeadvertence')
@commands.has_permissions(kick_members=True)
async def removeadvertence(ctx, member: discord.Member, warn_id: int):
    """Remove uma advert√™ncia de um membro"""
    if TEST_MODE:
        initial_count = len(test_db['warns'])
        test_db['warns'] = [w for w in test_db['warns'] if not (w['user_id'] == member.id and w['warn_id'] == warn_id)]
        removed = initial_count != len(test_db['warns'])
    else:
        with get_db() as conn:
            result = conn.execute("DELETE FROM warns WHERE user_id = ? AND warn_id = ?", (member.id, warn_id))
            conn.commit()
            removed = result.rowcount > 0
    
    if not removed:
        await ctx.send(f"‚ùå Advert√™ncia #{warn_id} n√£o encontrada para {member.mention}!")
    else:
        await ctx.send(f"‚úÖ Advert√™ncia #{warn_id} removida de {member.mention}")
        await registrar_log("remove_warn", ctx.author, member, f"Advert√™ncia ID: {warn_id}")

@bot.command(name='mutecall')
@commands.has_permissions(mute_members=True)
async def mutecall(ctx, member: discord.Member):
    """Muta um membro na call de voz"""
    if not member.voice:
        return await ctx.send("‚ùå O membro n√£o est√° em uma call de voz!")
    
    await member.edit(mute=True)
    await ctx.send(f"üîá {member.mention} foi mutado na call de voz!")
    await registrar_log("mute_call", ctx.author, member)

@bot.command(name='unmutecall')
@commands.has_permissions(mute_members=True)
async def unmutecall(ctx, member: discord.Member):
    """Desmuta um membro na call de voz"""
    if not member.voice:
        return await ctx.send("‚ùå O membro n√£o est√° em uma call de voz!")
    
    await member.edit(mute=False)
    await ctx.send(f"üîä {member.mention} foi desmutado na call de voz!")
    await registrar_log("unmute_call", ctx.author, member)

@bot.command(name='unbanall')
@commands.has_permissions(ban_members=True)
async def unbanall(ctx):
    """Desbane todos os membros banidos"""
    banned_users = await ctx.guild.bans()
    
    if not banned_users:
        return await ctx.send("‚ÑπÔ∏è N√£o h√° membros banidos para desbanir!")
    
    for ban_entry in banned_users:
        await ctx.guild.unban(ban_entry.user)
    
    await ctx.send(f"‚úÖ {len(banned_users)} membros foram desbanidos!")
    await registrar_log("unban_all", ctx.author)

# ================= COMANDOS DE STAFF EXPANDIDOS =================
# Sistema de pontos para staff
def init_staff_tables():
    """Inicializa tabelas espec√≠ficas para staff"""
    if not TEST_MODE:
        with get_db() as conn:
            conn.execute("""
            CREATE TABLE IF NOT EXISTS staff_points (
                user_id INTEGER PRIMARY KEY,
                migrations INTEGER DEFAULT 0,
                movchats INTEGER DEFAULT 0,
                movs INTEGER DEFAULT 0,
                recruitments INTEGER DEFAULT 0,
                registers INTEGER DEFAULT 0,
                verifications INTEGER DEFAULT 0,
                total_points INTEGER DEFAULT 0,
                last_reset TEXT
            )
            """)
            conn.commit()

async def get_staff_data(user_id):
    """Obt√©m dados de staff do usu√°rio"""
    if TEST_MODE:
        return test_db.get('staff', {}).get(str(user_id), {
            'migrations': 0, 'movchats': 0, 'movs': 0,
            'recruitments': 0, 'registers': 0, 'verifications': 0,
            'total_points': 0
        })
    else:
        with get_db() as conn:
            data = conn.execute(
                "SELECT * FROM staff_points WHERE user_id = ?",
                (user_id,)
            ).fetchone()
            
            if not data:
                conn.execute(
                    "INSERT INTO staff_points (user_id) VALUES (?)",
                    (user_id,)
                )
                conn.commit()
                return {
                    'migrations': 0, 'movchats': 0, 'movs': 0,
                    'recruitments': 0, 'registers': 0, 'verifications': 0,
                    'total_points': 0
                }
            
            return {
                'migrations': data['migrations'],
                'movchats': data['movchats'],
                'movs': data['movs'],
                'recruitments': data['recruitments'],
                'registers': data['registers'],
                'verifications': data['verifications'],
                'total_points': data['total_points']
            }

async def update_staff_points(user_id, category, points=1):
    """Atualiza pontos de staff"""
    if TEST_MODE:
        if 'staff' not in test_db:
            test_db['staff'] = {}
        if str(user_id) not in test_db['staff']:
            test_db['staff'][str(user_id)] = {
                'migrations': 0, 'movchats': 0, 'movs': 0,
                'recruitments': 0, 'registers': 0, 'verifications': 0,
                'total_points': 0
            }
        
        test_db['staff'][str(user_id)][category] += points
        test_db['staff'][str(user_id)]['total_points'] += points
    else:
        with get_db() as conn:
            conn.execute(f"""
            INSERT INTO staff_points (user_id, {category}, total_points)
            VALUES (?, ?, ?)
            ON CONFLICT(user_id) DO UPDATE SET
                {category} = {category} + ?,
                total_points = total_points + ?
            """, (user_id, points, points, points, points))
            conn.commit()

@bot.command(name='migrar')
@commands.has_permissions(move_members=True)
async def migrar_membro(ctx, member: discord.Member, channel: discord.VoiceChannel):
    """Migra um membro para outro canal de voz"""
    if not member.voice:
        await ctx.send("‚ùå O membro n√£o est√° em um canal de voz!")
        return
    
    old_channel = member.voice.channel.name
    await member.move_to(channel)
    await update_staff_points(ctx.author.id, 'migrations')
    
    embed = discord.Embed(
        title="üîÑ Migra√ß√£o Realizada",
        description=f"{member.mention} foi movido para {channel.mention}",
        color=0x00ff00
    )
    embed.add_field(name="De", value=old_channel, inline=True)
    embed.add_field(name="Para", value=channel.name, inline=True)
    embed.add_field(name="Staff", value=ctx.author.mention, inline=True)
    
    await ctx.send(embed=embed)
    await registrar_log("migra√ß√£o", ctx.author, member, f"Para: {channel.name}")

@bot.command(name='migracoes')
async def ver_migracoes(ctx, member: discord.Member = None):
    """Mostra estat√≠sticas de migra√ß√µes"""
    member = member or ctx.author
    staff_data = await get_staff_data(member.id)
    
    embed = discord.Embed(
        title=f"üîÑ Migra√ß√µes - {member.display_name}",
        color=0x3498db
    )
    embed.add_field(name="Total de Migra√ß√µes", value=staff_data['migrations'], inline=True)
    embed.add_field(name="Pontos Ganhos", value=f"{staff_data['migrations']} pts", inline=True)
    embed.set_thumbnail(url=member.avatar.url)
    
    await ctx.send(embed=embed)

@bot.command(name='movchat')
@commands.has_permissions(manage_messages=True)
async def mover_chat(ctx, member: discord.Member, channel: discord.TextChannel):
    """Move conversa de um membro para outro canal"""
    await update_staff_points(ctx.author.id, 'movchats')
    
    embed = discord.Embed(
        title="üí¨ Chat Movido",
        description=f"Conversa de {member.mention} direcionada para {channel.mention}",
        color=0x9932cc
    )
    embed.add_field(name="Staff", value=ctx.author.mention, inline=True)
    
    await ctx.send(embed=embed)
    await channel.send(f"üëã {member.mention}, continue sua conversa aqui!")
    await registrar_log("mov_chat", ctx.author, member, f"Para: {channel.name}")

@bot.command(name='mov')
@commands.has_permissions(move_members=True)
async def mover_geral(ctx, member: discord.Member, *, destino):
    """Move membro (comando gen√©rico)"""
    await update_staff_points(ctx.author.id, 'movs')
    
    embed = discord.Embed(
        title="‚ÜóÔ∏è Movimenta√ß√£o",
        description=f"{member.mention} foi direcionado",
        color=0x17a2b8
    )
    embed.add_field(name="Destino", value=destino, inline=True)
    embed.add_field(name="Staff", value=ctx.author.mention, inline=True)
    
    await ctx.send(embed=embed)
    await registrar_log("movimenta√ß√£o", ctx.author, member, f"Destino: {destino}")

@bot.command(name='movpoints')
async def ver_mov_points(ctx, member: discord.Member = None):
    """Mostra pontos de movimenta√ß√µes"""
    member = member or ctx.author
    staff_data = await get_staff_data(member.id)
    
    embed = discord.Embed(
        title=f"üìä Pontos de Movimenta√ß√£o - {member.display_name}",
        color=0x17a2b8
    )
    embed.add_field(name="üîÑ Migra√ß√µes", value=staff_data['migrations'], inline=True)
    embed.add_field(name="üí¨ MovChats", value=staff_data['movchats'], inline=True)
    embed.add_field(name="‚ÜóÔ∏è Movs", value=staff_data['movs'], inline=True)
    embed.add_field(name="üèÜ Total", value=staff_data['total_points'], inline=False)
    
    await ctx.send(embed=embed)

@bot.command(name='recrutar')
@commands.has_permissions(manage_roles=True)
async def recrutar_membro(ctx, member: discord.Member, *, cargo_ou_area):
    """Recruta um membro para uma √°rea"""
    await update_staff_points(ctx.author.id, 'recruitments')
    
    embed = discord.Embed(
        title="üéØ Recrutamento",
        description=f"{member.mention} foi recrutado!",
        color=0x28a745
    )
    embed.add_field(name="√Årea/Cargo", value=cargo_ou_area, inline=True)
    embed.add_field(name="Recrutador", value=ctx.author.mention, inline=True)
    embed.set_thumbnail(url=member.avatar.url)
    
    await ctx.send(embed=embed)
    await registrar_log("recrutamento", ctx.author, member, f"√Årea: {cargo_ou_area}")

@bot.command(name='recrutamentos')
async def ver_recrutamentos(ctx, member: discord.Member = None):
    """Mostra estat√≠sticas de recrutamentos"""
    member = member or ctx.author
    staff_data = await get_staff_data(member.id)
    
    embed = discord.Embed(
        title=f"üéØ Recrutamentos - {member.display_name}",
        color=0x28a745
    )
    embed.add_field(name="Total Recrutados", value=staff_data['recruitments'], inline=True)
    embed.add_field(name="Pontos Ganhos", value=f"{staff_data['recruitments']} pts", inline=True)
    
    await ctx.send(embed=embed)

@bot.command(name='registers')
async def ver_registros(ctx, member: discord.Member = None):
    """Mostra estat√≠sticas de registros"""
    member = member or ctx.author
    staff_data = await get_staff_data(member.id)
    
    embed = discord.Embed(
        title=f"üìù Registros - {member.display_name}",
        color=0x6f42c1
    )
    embed.add_field(name="Total Registros", value=staff_data['registers'], inline=True)
    embed.add_field(name="Pontos Ganhos", value=f"{staff_data['registers']} pts", inline=True)
    
    await ctx.send(embed=embed)

@bot.command(name='verificacoes')
async def ver_verificacoes(ctx, member: discord.Member = None):
    """Mostra estat√≠sticas de verifica√ß√µes"""
    member = member or ctx.author
    staff_data = await get_staff_data(member.id)
    
    embed = discord.Embed(
        title=f"‚úÖ Verifica√ß√µes - {member.display_name}",
        color=0x20c997
    )
    embed.add_field(name="Total Verifica√ß√µes", value=staff_data['verifications'], inline=True)
    embed.add_field(name="Pontos Ganhos", value=f"{staff_data['verifications']} pts", inline=True)
    
    await ctx.send(embed=embed)

# Comandos de reset para staff
@bot.command(name='resetmigs')
@commands.has_permissions(administrator=True)
async def reset_migrations(ctx, member: discord.Member):
    """Reseta contador de migra√ß√µes de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)]['migrations'] = 0
    else:
        with get_db() as conn:
            conn.execute("UPDATE staff_points SET migrations = 0 WHERE user_id = ?", (member.id,))
            conn.commit()
    
    await ctx.send(f"‚úÖ Contador de migra√ß√µes resetado para {member.mention}")

@bot.command(name='resetmovchat')
@commands.has_permissions(administrator=True)
async def reset_movchats(ctx, member: discord.Member):
    """Reseta contador de movchats de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)]['movchats'] = 0
    else:
        with get_db() as conn:
            conn.execute("UPDATE staff_points SET movchats = 0 WHERE user_id = ?", (member.id,))
            conn.commit()
    
    await ctx.send(f"‚úÖ Contador de movchats resetado para {member.mention}")

@bot.command(name='resetmovs')
@commands.has_permissions(administrator=True)
async def reset_movs(ctx, member: discord.Member):
    """Reseta contador de movs de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)]['movs'] = 0
    else:
        with get_db() as conn:
            conn.execute("UPDATE staff_points SET movs = 0 WHERE user_id = ?", (member.id,))
            conn.commit()
    
    await ctx.send(f"‚úÖ Contador de movs resetado para {member.mention}")

@bot.command(name='resetrecs')
@commands.has_permissions(administrator=True)
async def reset_recruitments(ctx, member: discord.Member):
    """Reseta contador de recrutamentos de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)]['recruitments'] = 0
    else:
        with get_db() as conn:
            conn.execute("UPDATE staff_points SET recruitments = 0 WHERE user_id = ?", (member.id,))
            conn.commit()
    
    await ctx.send(f"‚úÖ Contador de recrutamentos resetado para {member.mention}")

@bot.command(name='resetregisters')
@commands.has_permissions(administrator=True)
async def reset_registers(ctx, member: discord.Member):
    """Reseta contador de registros de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)]['registers'] = 0
    else:
        with get_db() as conn:
            conn.execute("UPDATE staff_points SET registers = 0 WHERE user_id = ?", (member.id,))
            conn.commit()
    
    await ctx.send(f"‚úÖ Contador de registros resetado para {member.mention}")

@bot.command(name='resetverificacoes')
@commands.has_permissions(administrator=True)
async def reset_verifications(ctx, member: discord.Member):
    """Reseta contador de verifica√ß√µes de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)]['verifications'] = 0
    else:
        with get_db() as conn:
            conn.execute("UPDATE staff_points SET verifications = 0 WHERE user_id = ?", (member.id,))
            conn.commit()
    
    await ctx.send(f"‚úÖ Contador de verifica√ß√µes resetado para {member.mention}")

@bot.command(name='resettime')
@commands.has_permissions(administrator=True)
async def reset_all_staff(ctx, member: discord.Member):
    """Reseta TODOS os contadores de um staff"""
    if TEST_MODE:
        if str(member.id) in test_db.get('staff', {}):
            test_db['staff'][str(member.id)] = {
                'migrations': 0, 'movchats': 0, 'movs': 0,
                'recruitments': 0, 'registers': 0, 'verifications': 0,
                'total_points': 0
            }
    else:
        with get_db() as conn:
            conn.execute("""
            UPDATE staff_points 
            SET migrations = 0, movchats = 0, movs = 0, 
                recruitments = 0, registers = 0, verifications = 0, 
                total_points = 0,
                last_reset = ?
            WHERE user_id = ?
            """, (datetime.now().strftime('%Y-%m-%d %H:%M:%S'), member.id))
            conn.commit()
    
    await ctx.send(f"üîÑ TODOS os contadores foram resetados para {member.mention}!")
    await registrar_log("reset_completo", ctx.author, member)

# ================= COMANDOS DE PERFIL/RANKING =================
@bot.command(name='perfil')

async def perfil(ctx):
    """Mostra o perfil completo do usu√°rio"""
    try:
        if TEST_MODE:
            user_id = str(ctx.author.id)
            if user_id not in test_db['users']:
                user_data = {
                    'level': 1,
                    'xp': 0,
                    'money': 0,
                    'rep': 0,
                    'vip_level': 0,
                    'about_me': None
                }
            else:
                user_data = {
                    'level': test_db['users'][user_id].get('level', 1),
                    'xp': test_db['users'][user_id].get('xp', 0),
                    'money': test_db['users'][user_id].get('money', 0),
                    'rep': test_db['users'][user_id].get('rep', 0),
                    'vip_level': test_db['users'][user_id].get('vip_level', 0),
                    'about_me': test_db['users'][user_id].get('about_me')
                }
        else:
            with get_db() as conn:
                user = conn.execute(
                    "SELECT * FROM users WHERE user_id = ?", 
                    (ctx.author.id,)
                ).fetchone()
            
            if not user:
                user_data = {
                    'level': 1,
                    'xp': 0,
                    'money': 0,
                    'rep': 0,
                    'vip_level': 0,
                    'about_me': None
                }
            else:
                user_data = {
                    'level': user['level'],
                    'xp': user['xp'],
                    'money': user['money'],
                    'rep': user['rep'],
                    'vip_level': user['vip_level'],
                    'about_me': user['about_me']
                }

        embed = discord.Embed(
            title=f"Perfil de {ctx.author.display_name}",
            color=0x00ff00
        )
        embed.add_field(name="üèÜ N√≠vel", value=user_data['level'], inline=True)
        embed.add_field(name="‚ú® XP", value=f"{user_data['xp']}/{user_data['level'] * 100}", inline=True)
        embed.add_field(name="üí∞ Moedas", value=user_data['money'], inline=True)
        embed.add_field(name="üåü Reputa√ß√£o", value=user_data['rep'], inline=True)
        embed.add_field(name="üíé VIP", value="Sim" if user_data['vip_level'] > 0 else "N√£o", inline=True)
        
        if user_data['about_me']:
            embed.add_field(name="üìù Sobre", value=user_data['about_me'], inline=False)
            
        embed.set_thumbnail(url=ctx.author.avatar.url)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send("‚ùå Erro ao carregar perfil")
        print(f"Erro no comando perfil: {e}")

@bot.command(name='top')
async def top(ctx):
    """Mostra o ranking de membros"""
    try:
        if TEST_MODE:
            users = []
            for user_id, data in test_db['users'].items():
                try:
                    member = ctx.guild.get_member(int(user_id))
                    if member:
                        users.append({
                            'user_id': user_id,
                            'level': data.get('level', 1),
                            'xp': data.get('xp', 0),
                            'money': data.get('money', 0),
                            'member': member
                        })
                except ValueError:
                    continue
            
            top_users = sorted(users, key=lambda x: (-x['level'], -x['xp']))[:10]
        else:
            with get_db() as conn:
                top_users = conn.execute(
                    "SELECT user_id, level, xp, money FROM users ORDER BY level DESC, xp DESC LIMIT 10"
                ).fetchall()
            
            top_users = [{
                'user_id': str(user['user_id']),
                'level': user['level'],
                'xp': user['xp'],
                'money': user['money'],
                'member': ctx.guild.get_member(int(user['user_id']))
            } for user in top_users]
        
        embed = discord.Embed(
            title="üèÜ Top 10 por n√≠vel",
            color=0xffd700
        )
        
        for i, user in enumerate(top_users, 1):
            if user['member']:
                embed.add_field(
                    name=f"{i}. {user['member'].display_name}",
                    value=f"N√≠vel {user['level']} | XP {user['xp']} | üí∞ {user['money']}",
                    inline=False
                )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send("‚ùå Erro ao carregar ranking")
        print(f"Erro no comando top: {e}")

# ================= COMANDO RESTART =================
    
    await ctx.send(embed=embed)

@bot.safe_command('debug')  # ‚Üê Modificado aqui
@commands.is_owner()
async def debug(ctx, action: str = "status"):
    """Sistema de debug avan√ßado"""
    
    if action == "status":
        embed = discord.Embed(
            title="üîß DEBUG - STATUS DO SISTEMA",
            color=0xff9900
        )
        
        # Estat√≠sticas de cache
        embed.add_field(
            name="üíæ Cache de Usu√°rios", 
            value=f"{len(user_cache)} entradas ativas",
            inline=True
        )
        
        # Estat√≠sticas de comandos
        total_executions = sum(len(execs) for execs in command_executions.values())
        embed.add_field(
            name="‚ö° Execu√ß√µes de Comandos", 
            value=f"{total_executions} na √∫ltima hora",
            inline=True
        )
        
        # Sistema de processamento
        embed.add_field(
            name="üîÑ Processamento Ativo", 
            value=f"{len(help_manager.processing_users)} comandos !f processando",
            inline=True
        )
        
        # Mensagens registradas
        embed.add_field(
            name="üì® Mensagens Ativas", 
            value=f"{len(help_manager.active_panels)} pain√©is ativos",
            inline=True
        )
        
        # Duplica√ß√µes detectadas
        embed.add_field(
            name="üö® Duplica√ß√µes Detectadas", 
            value=f"{len(duplicate_alerts)} alertas",
            inline=True
        )
        
        # Uptime
        embed.add_field(
            name="üïê Status", 
            value="Sistema funcionando normalmente",
            inline=True
        )
        
        await ctx.send(embed=embed)
    
    elif action == "logs":
        # Mostra logs de execu√ß√µes recentes
        embed = discord.Embed(
            title="üìã DEBUG - LOGS DE COMANDOS",
            color=0x00ff00
        )
        
        log_lines = []
        for key, executions in list(command_executions.items())[-10:]:  # √öltimas 10
            if executions:
                command_name = key.split('_')[0]
                user_id = key.split('_')[1]
                count = len(executions)
                last_exec = executions[-1]['timestamp']
                time_ago = (datetime.now() - last_exec).seconds
                
                log_lines.append(f"`{command_name}` - User {user_id} - {count}x - {time_ago}s atr√°s")
        
        embed.description = "\\n".join(log_lines) if log_lines else "Nenhuma execu√ß√£o recente"
        await ctx.send(embed=embed)
    
    elif action == "clear":
        # Limpa todos os dados de debug
        command_executions.clear()
        duplicate_alerts.clear()
        # Sistema antigo removido - usa singleton help_manager
        user_cache.clear()
        
        # Limpa tamb√©m o sistema novo
        async with help_manager._lock:
            help_manager.active_panels.clear()
            help_manager.processing_users.clear()
            help_manager.last_request.clear()
        
        logging.info("Sistema de debug limpo pelo administrador")
        await ctx.send("üßπ **Debug limpo!** Todos os dados foram resetados.")
    
    elif action == "test":
        # Teste de sistema
        test_results = []
        
        # Teste 1: Cache
        try:
            test_data = await get_cached_user_data(ctx.author.id)
            test_results.append("‚úÖ Cache funcionando")
        except:
            test_results.append("‚ùå Cache com erro")
        
        # Teste 2: Logging
        try:
            logging.info("Teste de logging executado")
            test_results.append("‚úÖ Logging funcionando")
        except:
            test_results.append("‚ùå Logging com erro")
        
        # Teste 3: Database
        try:
            with get_db() as conn:
                conn.execute("SELECT 1").fetchone()
            test_results.append("‚úÖ Database funcionando")
        except:
            test_results.append("‚ùå Database com erro")
        
        embed = discord.Embed(
            title="üß™ TESTE DE SISTEMA",
            description="\\n".join(test_results),
            color=0x00ffff
        )
        await ctx.send(embed=embed)
    
    else:
        await ctx.send("‚ùå **A√ß√µes dispon√≠veis:** `status`, `logs`, `clear`, `test`")

@bot.command(name='commandstats')
@commands.is_owner()
async def command_stats(ctx):
    """Mostra estat√≠sticas detalhadas de comandos (apenas dono)"""
    
    if not command_executions:
        await ctx.send("üìä Nenhuma estat√≠stica de comando dispon√≠vel.")
        return
    
    # Analisa dados
    stats = {}
    for key, executions in command_executions.items():
        command_name = key.split('_')[0]
        if command_name not in stats:
            stats[command_name] = {
                'total': 0,
                'users': set(),
                'duplicates': 0
            }
        
        stats[command_name]['total'] += len(executions)
        stats[command_name]['users'].add(key.split('_')[1])
        
        # Detecta duplica√ß√µes
        if len(executions) > 1:
            for i in range(1, len(executions)):
                time_diff = (executions[i]['timestamp'] - executions[i-1]['timestamp']).total_seconds()
                if time_diff < 3:
                    stats[command_name]['duplicates'] += 1
    
    # Cria embed
    embed = discord.Embed(
        title="üìä ESTAT√çSTICAS DE COMANDOS",
        color=0x9932cc
    )
    
    sorted_stats = sorted(stats.items(), key=lambda x: x[1]['total'], reverse=True)
    
    for command, data in sorted_stats[:15]:  # Top 15
        value = f"**Execu√ß√µes:** {data['total']}\\n**Usu√°rios √∫nicos:** {len(data['users'])}\\n**Duplica√ß√µes:** {data['duplicates']}"
        embed.add_field(
            name=f"`!{command}`",
            value=value,
            inline=True
        )
    
    embed.set_footer(text=f"Dados dos √∫ltimos 60 minutos ‚Ä¢ {len(stats)} comandos analisados")
    await ctx.send(embed=embed)

# ================= COMANDOS SOCIAIS EXPANDIDOS =================
@bot.command(name='sobremim')
async def sobre_mim(ctx, *, texto=None):
    """Define ou mostra informa√ß√µes sobre voc√™"""
    if not texto:
        # Mostra o 'sobre mim' atual
        user_data = await get_user_data(ctx.author.id)
        about = user_data.get('about_me') or "Nenhuma descri√ß√£o definida"
        
        embed = discord.Embed(
            title=f"üìã Sobre {ctx.author.display_name}",
            description=about,
            color=0x00ff00
        )
        embed.set_thumbnail(url=ctx.author.avatar.url)
        await ctx.send(embed=embed)
    else:
        # Define novo 'sobre mim'
        if len(texto) > 500:
            await ctx.send("‚ùå Descri√ß√£o muito longa! M√°ximo 500 caracteres.")
            return
            
        if TEST_MODE:
            user_id = str(ctx.author.id)
            if user_id not in test_db['users']:
                test_db['users'][user_id] = {}
            test_db['users'][user_id]['about_me'] = texto
        else:
            with get_db() as conn:
                conn.execute(
                    "INSERT INTO users (user_id, about_me) VALUES (?, ?) ON CONFLICT(user_id) DO UPDATE SET about_me = ?",
                    (ctx.author.id, texto, texto)
                )
                conn.commit()
        
        await ctx.send(f"‚úÖ Sua descri√ß√£o foi atualizada para: **{texto}**")

@bot.command(name='influencer')
async def influencer_stats(ctx, member: discord.Member = None):
    """Mostra estat√≠sticas de influenciador no servidor"""
    member = member or ctx.author
    
    # Calcula estat√≠sticas baseadas em atividade
    messages_sent = 0
    reactions_received = 0
    
    # Simula dados (em produ√ß√£o, voc√™ coletaria dados reais)
    async for message in ctx.channel.history(limit=100):
        if message.author == member:
            messages_sent += 1
            reactions_received += len(message.reactions)
    
    influence_score = (messages_sent * 2) + (reactions_received * 5)
    
    embed = discord.Embed(
        title=f"üìà Stats de Influenciador - {member.display_name}",
        color=0xff69b4
    )
    embed.add_field(name="üì± Mensagens Enviadas", value=messages_sent, inline=True)
    embed.add_field(name="‚ù§Ô∏è Rea√ß√µes Recebidas", value=reactions_received, inline=True)
    embed.add_field(name="üåü Pontua√ß√£o de Influ√™ncia", value=influence_score, inline=False)
    
    if influence_score >= 100:
        embed.add_field(name="üèÜ Status", value="MEGA INFLUENCER!", inline=False)
    elif influence_score >= 50:
        embed.add_field(name="ü•á Status", value="Influencer Ativo", inline=False)
    else:
        embed.add_field(name="üìä Status", value="Influencer Iniciante", inline=False)
    
    embed.set_thumbnail(url=member.avatar.url)
    await ctx.send(embed=embed)

# Sistema Tellonym com bot√µes interativos
class TellonymView(discord.ui.View):
    def __init__(self, post_author):
        super().__init__(timeout=300)
        self.post_author = post_author
        self.likes = set()
        self.comments = []
    
    @discord.ui.button(label="‚ù§Ô∏è Curtir", style=discord.ButtonStyle.red)
    async def like_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        if user_id in self.likes:
            self.likes.remove(user_id)
            button.label = f"‚ù§Ô∏è Curtir ({len(self.likes)})"
            await interaction.response.edit_message(view=self)
        else:
            self.likes.add(user_id)
            button.label = f"‚ù§Ô∏è Curtir ({len(self.likes)})"
            await interaction.response.edit_message(view=self)
    
    @discord.ui.button(label="üí¨ Comentar", style=discord.ButtonStyle.grey)
    async def comment_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(CommentModal(self))
    
    @discord.ui.button(label="üóëÔ∏è Apagar", style=discord.ButtonStyle.red)
    async def delete_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        # S√≥ o autor ou moderadores podem apagar
        if interaction.user.id == self.post_author or interaction.user.guild_permissions.manage_messages:
            await interaction.response.edit_message(content="**Post deletado pelo autor/moderador**", embed=None, view=None)
        else:
            await interaction.response.send_message("‚ùå Voc√™ n√£o tem permiss√£o para deletar este post!", ephemeral=True)

class CommentModal(discord.ui.Modal, title="Comentar anonimamente"):
    def __init__(self, view):
        super().__init__()
        self.view = view
    
    comment = discord.ui.TextInput(
        label="Seu coment√°rio an√¥nimo:",
        placeholder="Digite seu coment√°rio aqui...",
        style=discord.TextStyle.paragraph,
        max_length=200
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        self.view.comments.append(f"**An√¥nimo:** {self.comment.value}")
        
        embed = discord.Embed(
            title="üí¨ Coment√°rios",
            description="\n\n".join(self.view.comments[-5:]),  # √öltimos 5 coment√°rios
            color=0x00ffff
        )
        if len(self.view.comments) > 5:
            embed.set_footer(text=f"Mostrando os 5 coment√°rios mais recentes de {len(self.view.comments)} total")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.command(name='tellonym')
async def tellonym_post(ctx, *, mensagem):
    """Posta uma mensagem an√¥nima com sistema de intera√ß√µes"""
    embed = discord.Embed(
        title="üìù Post An√¥nimo",
        description=mensagem,
        color=0x9932cc,
        timestamp=datetime.now(timezone.utc)
    )
    embed.set_footer(text="Sistema Tellonym ‚Ä¢ Clique nos bot√µes para interagir")
    
    view = TellonymView(ctx.author.id)
    await ctx.message.delete()  # Remove a mensagem original para manter anonimato
    await ctx.send(embed=embed, view=view)

# Sistema Instagram com foto e intera√ß√µes
class InstagramView(discord.ui.View):
    def __init__(self, post_author):
        super().__init__(timeout=600)
        self.post_author = post_author
        self.likes = set()
        self.comments = []
    
    @discord.ui.button(label="‚ù§Ô∏è 0", style=discord.ButtonStyle.red)
    async def like_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Bot√£o de curtir com logging para debug"""
        try:
            user_id = interaction.user.id
            logger_main.debug(f"Like button clicked by user {user_id}")
            
            if user_id in self.likes:
                self.likes.remove(user_id)
                button.label = f"‚ù§Ô∏è {len(self.likes)}"
                logger_main.debug(f"User {user_id} removed like, total: {len(self.likes)}")
            else:
                self.likes.add(user_id)
                button.label = f"‚ù§Ô∏è {len(self.likes)}"
                logger_main.debug(f"User {user_id} added like, total: {len(self.likes)}")
            
            await interaction.response.edit_message(view=self)
            logger_main.debug(f"Like button interaction completed successfully for user {user_id}")
            
        except Exception as e:
            logger_main.error(f"Erro no like button: {e}")
            try:
                await interaction.response.send_message("‚ùå Erro ao processar curtida!", ephemeral=True)
            except:
                pass
    
    @discord.ui.button(label="üí¨ Comentar", style=discord.ButtonStyle.grey)
    async def comment_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(InstagramCommentModal(self, interaction.user))
    
    @discord.ui.button(label="üëÅÔ∏è Ver Curtidas", style=discord.ButtonStyle.green)
    async def view_likes(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.likes:
            await interaction.response.send_message("Nenhuma curtida ainda!", ephemeral=True)
            return
        
        users = []
        for user_id in list(self.likes)[:10]:  # M√°ximo 10
            user = interaction.guild.get_member(user_id)
            if user:
                users.append(user.display_name)
        
        embed = discord.Embed(
            title=f"‚ù§Ô∏è Curtidas ({len(self.likes)})",
            description="\n".join(users),
            color=0xff1493
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
    
    @discord.ui.button(label="üí¨ Ver Coment√°rios", style=discord.ButtonStyle.blurple)
    async def view_comments(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.comments:
            await interaction.response.send_message("Nenhum coment√°rio ainda!", ephemeral=True)
            return
        
        embed = discord.Embed(
            title=f"üí¨ Coment√°rios ({len(self.comments)})",
            description="\n\n".join(self.comments[-10:]),  # √öltimos 10
            color=0x00bfff
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
    
    @discord.ui.button(label="üóëÔ∏è Deletar", style=discord.ButtonStyle.red)
    async def delete_post(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id == self.post_author or interaction.user.guild_permissions.manage_messages:
            await interaction.response.edit_message(
                content="**üì∏ Post deletado**", 
                embed=None, 
                view=None
            )
        else:
            await interaction.response.send_message("‚ùå S√≥ o autor ou moderadores podem deletar!", ephemeral=True)

class InstagramCommentModal(discord.ui.Modal, title="Comentar no post"):
    def __init__(self, view, user):
        super().__init__()
        self.view = view
        self.user = user
    
    comment = discord.ui.TextInput(
        label="Seu coment√°rio:",
        placeholder="Digite seu coment√°rio...",
        style=discord.TextStyle.short,
        max_length=150
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        self.view.comments.append(f"**{self.user.display_name}:** {self.comment.value}")
        await interaction.response.send_message("üí¨ Coment√°rio adicionado!", ephemeral=True)

@bot.command(name='instagram')
async def instagram_post(ctx, url_imagem=None, *, legenda=""):
    """Posta uma foto estilo Instagram com sistema completo de intera√ß√µes"""
    if not url_imagem:
        if ctx.message.attachments:
            url_imagem = ctx.message.attachments[0].url
        else:
            await ctx.send("‚ùå Forne√ßa uma URL de imagem ou anexe uma foto!")
            return
    
    embed = discord.Embed(
        title=f"üì∏ Post de {ctx.author.display_name}",
        description=legenda if legenda else "*Sem legenda*",
        color=0xe4405f,
        timestamp=datetime.now(timezone.utc)
    )
    embed.set_image(url=url_imagem)
    embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.avatar.url)
    embed.set_footer(text="üì± Instagram Bot ‚Ä¢ Interaja com os bot√µes")
    
    view = InstagramView(ctx.author.id)
    await ctx.send(embed=embed, view=view)

@bot.command(name='ping')
async def ping_command(ctx):
    """Mostra a lat√™ncia do bot"""
    latency = round(bot.latency * 1000)
    embed = discord.Embed(
        title="üèì Pong!",
        description=f"Lat√™ncia: **{latency}ms**",
        color=0x00ff00 if latency < 100 else 0xff9900 if latency < 200 else 0xff0000
    )
    await ctx.send(embed=embed)

@bot.command(name='restart')
@commands.is_owner()
async def restart_bot(ctx):
    """Reinicia o bot (apenas dono)"""
    embed = discord.Embed(
        title="üîÑ Reiniciando Bot...",
        description="O bot est√° sendo reiniciado pelo dono.",
        color=0xff9900
    )
    embed.set_thumbnail(url=bot.user.avatar.url)
    embed.set_footer(text=f"Solicitado por {ctx.author.display_name}", icon_url=ctx.author.avatar.url)
    
    await ctx.send(embed=embed)
    await ctx.send("‚ö†Ô∏è O bot ser√° reiniciado agora!")
    os.execv(sys.executable, ['python'] + [__file__])

@bot.command(name='reload')
@commands.is_owner()
async def reload_bot(ctx):
    """Recarrega o bot completamente (apenas dono)"""
    await ctx.send("üîÑ Recarregando bot...")
    
    # Limpa cache
    user_cache.clear()
    
    # Executa o arquivo novamente
    os.execv(sys.executable, ['python'] + [__file__])

@bot.command(name='forceclear')
@commands.is_owner()
async def force_clear_help(ctx):
    """For√ßa limpeza completa do sistema de ajuda profissional"""
    # Reset completo do singleton
    async with help_manager._lock:
        # Deleta todos os pain√©is ativos
        for user_id, message in list(help_manager.active_panels.items()):
            try:
                await message.delete()
            except:
                pass
        
        # Limpa todos os registros
        help_manager.active_panels.clear()
        help_manager.processing_users.clear()
        help_manager.last_request.clear()
    
    # Limpa pain√©is no canal atual (backup)
    deleted = 0
    async for msg in ctx.channel.history(limit=50):
        if (msg.author == bot.user and msg.embeds and 
            "PAINEL DE AJUDA" in str(msg.embeds[0].title)):
            try:
                await msg.delete()
                deleted += 1
            except:
                pass
    
    await ctx.send(f"üßπ **LIMPEZA FOR√áADA CONCLU√çDA v3.0**\\n- Sistema singleton resetado\\n- {deleted} pain√©is do canal removidos\\n- Todas as sess√µes limpas")

@bot.safe_command('helpstatus')  # SISTEMA PROFISSIONAL v3.0
@commands.is_owner()
async def helpstatus(ctx):
    """Status do sistema de ajuda profissional com singleton"""
    status = help_manager.get_status() if 'help_manager' in globals() else {}
    
    embed = discord.Embed(
        title="üìå STATUS DO SISTEMA DE AJUDA v3.0 PROFISSIONAL",
        description="**Sistema Singleton + Circuit Breaker**",
        color=0x00ff00
    )
    
    # Status atual
    embed.add_field(name="üîÑ Processamentos Ativos", value=status.get('processing_users', 0), inline=True)
    embed.add_field(name="üì® Pain√©is Ativos", value=status.get('active_panels', 0), inline=True)
    embed.add_field(name="üîí Singleton Lock", value="‚úÖ ATIVO", inline=True)
    
    # Lista usu√°rios com pain√©is
    if status.get('users_with_panels'):
        users_list = ", ".join([f"<@{uid}>" for uid in status['users_with_panels'][:5]])
        if len(status['users_with_panels']) > 5:
            users_list += f" ... e mais {len(status['users_with_panels']) - 5}"
        embed.add_field(name="üë• Usu√°rios com Pain√©is", value=users_list, inline=False)
    
    # Lista usu√°rios processando
    if status.get('users_processing'):
        processing_list = ", ".join([f"<@{uid}>" for uid in status['users_processing']])
        embed.add_field(name="‚öôÔ∏è Processando Agora", value=processing_list, inline=False)
    
    embed.set_footer(text="‚úÖ Sistema v3.0: Singleton Pattern + Circuit Breaker + Zero Duplica√ß√£o")
    await ctx.send(embed=embed)

@bot.command(name='debug')
@commands.is_owner()
async def debug_command(ctx, action: str = "status"):
    """Sistema de debug avan√ßado (apenas dono)"""
    
    if action == "status":
        embed = discord.Embed(
            title="üîß DEBUG - STATUS DO SISTEMA",
            color=0xff9900
        )
        
        # Estat√≠sticas de cache
        embed.add_field(
            name="üíæ Cache de Usu√°rios", 
            value=f"{len(user_cache)} entradas ativas",
            inline=True
        )
        
    
        
        await ctx.send(embed=embed)
    
    elif action == "logs":
        # Mostra logs de execu√ß√µes recentes
        embed = discord.Embed(
            title="üìã DEBUG - LOGS DE COMANDOS",
            color=0x00ff00
        )
        
        log_lines = []
        for key, executions in list(command_executions.items())[-10:]:  # √öltimas 10
            if executions:
                command_name = key.split('_')[0]
                user_id = key.split('_')[1]
                count = len(executions)
                last_exec = executions[-1]['timestamp']
                time_ago = (datetime.now() - last_exec).seconds
                
                log_lines.append(f"`{command_name}` - User {user_id} - {count}x - {time_ago}s atr√°s")
        
        embed.description = "\\n".join(log_lines) if log_lines else "Nenhuma execu√ß√£o recente"
        await ctx.send(embed=embed)
    
    elif action == "clear":
        # Limpa todos os dados de debug
        command_executions.clear()
        duplicate_alerts.clear()
        # Sistema antigo removido - usa singleton help_manager
        user_cache.clear()
        
        logger.log("Sistema de debug limpo pelo administrador", level="INFO")
        await ctx.send("üßπ **Debug limpo!** Todos os dados foram resetados.")
    
    elif action == "test":
        # Teste de sistema
        test_results = []
        
        # Teste 1: Cache
        try:
            test_data = await get_cached_user_data(ctx.author.id)
            test_results.append("‚úÖ Cache funcionando")
        except:
            test_results.append("‚ùå Cache com erro")
        
        # Teste 2: Logging
        try:
            logger.log("Teste de logging executado", level="INFO")
            test_results.append("‚úÖ Logging funcionando")
        except:
            test_results.append("‚ùå Logging com erro")
        
        # Teste 3: Database
        try:
            with get_db() as conn:
                conn.execute("SELECT 1").fetchone()
            test_results.append("‚úÖ Database funcionando")
        except:
            test_results.append("‚ùå Database com erro")
        
        embed = discord.Embed(
            title="üß™ TESTE DE SISTEMA",
            description="\\n".join(test_results),
            color=0x00ffff
        )
        await ctx.send(embed=embed)
    
    else:
        await ctx.send("‚ùå **A√ß√µes dispon√≠veis:** `status`, `logs`, `clear`, `test`")



# ================= COMANDOS SOCIAIS =================
@bot.command(name='avatar')
async def avatar(ctx, member: discord.Member = None):
    """Mostra o avatar de um membro em alta resolu√ß√£o"""
    member = member or ctx.author
    embed = discord.Embed(
        title=f"üñºÔ∏è Avatar de {member.display_name}",
        color=0x00ffff
    )
    embed.set_image(url=member.avatar.url)
    await ctx.send(embed=embed)

@bot.command(name='rep')
async def rep(ctx, member: discord.Member):
    """D√° reputa√ß√£o para um membro"""
    if member.id == ctx.author.id:
        await ctx.send("‚ùå Voc√™ n√£o pode dar rep para si mesmo!")
        return
    
    cooldown = 86400  # 24 horas
    last_rep = test_db['users'].get(str(ctx.author.id), {}).get('last_rep') if TEST_MODE else None
    
    if last_rep and (datetime.now() - datetime.strptime(last_rep, '%Y-%m-%d %H:%M:%S')).seconds < cooldown:
        await ctx.send("‚è≥ Voc√™ s√≥ pode dar rep uma vez por dia!")
        return
    
    if TEST_MODE:
        user_id = str(member.id)
        if user_id not in test_db['users']:
            test_db['users'][user_id] = {'rep': 0}
        test_db['users'][user_id]['rep'] = test_db['users'][user_id].get('rep', 0) + 1
        
        # Registrar cooldown
        author_id = str(ctx.author.id)
        if author_id not in test_db['users']:
            test_db['users'][author_id] = {}
        test_db['users'][author_id]['last_rep'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    else:
        with get_db() as conn:
            conn.execute(
                "UPDATE users SET rep = rep + 1 WHERE user_id = ?",
                (member.id,)
            )
            # Registrar cooldown
            conn.execute(
                "UPDATE users SET last_rep = ? WHERE user_id = ?",
                (datetime.now().strftime('%Y-%m-%d %H:%M:%S'), ctx.author.id)
            )
            conn.commit()
    
    await ctx.send(f"üåü {ctx.author.mention} deu +1 de reputa√ß√£o para {member.mention}!")

# ================= UTILIT√ÅRIOS =================
@bot.command(name='membersrole')
async def membersrole(ctx, role: discord.Role):
    """Lista todos os membros com um determinado cargo"""
    members = [member for member in ctx.guild.members if role in member.roles]
    
    if not members:
        await ctx.send(f"‚ùå Nenhum membro encontrado com o cargo {role.name}!")
        return
    
    embed = discord.Embed(
        title=f"üë• Membros com o cargo {role.name}",
        description="\n".join([member.mention for member in members]),
        color=role.color
    )
    embed.set_footer(text=f"Total: {len(members)} membros")
    
    await ctx.send(embed=embed)

# ================= COMANDOS ADICIONAIS =================
@bot.command(name='clear')
@commands.has_permissions(manage_messages=True)
async def clear_messages(ctx, limite: int = 50):
    """Alias para o comando cl"""
    await limpar(ctx, limite)

@bot.command(name='botinfo')
async def bot_info_alias(ctx):
    """Alias para o comando linfo"""
    await linfo(ctx)

# ================= OTIMIZA√á√ïES E CORRE√á√ïES =================

# Inicializa tabelas de staff quando o bot inicia
def init_all_tables():
    """Inicializa todas as tabelas necess√°rias"""
    init_db()
    init_perm_db()
    if not TEST_MODE:
        init_staff_tables()
        print("‚úÖ Todas as tabelas inicializadas")

# Sistema de cache para melhor performance
user_cache = {}
cache_timeout = 300  # 5 minutos

async def get_cached_user_data(user_id):
    """Busca dados do usu√°rio com cache para otimizar performance"""
    current_time = datetime.now().timestamp()
    
    # Verifica se existe cache v√°lido
    if user_id in user_cache:
        cache_entry = user_cache[user_id]
        if current_time - cache_entry['timestamp'] < cache_timeout:
            return cache_entry['data']
    
    # Busca dados atualizados
    user_data = await get_user_data(user_id)
    
    # Atualiza cache
    user_cache[user_id] = {
        'data': user_data,
        'timestamp': current_time
    }
    
    return user_data

# Fun√ß√£o para limpar cache periodicamente
@tasks.loop(minutes=30)
async def clear_cache():
    """Limpa cache antigo para evitar uso excessivo de mem√≥ria"""
    current_time = datetime.now().timestamp()
    expired_keys = []
    
    # Limpa cache de usu√°rios
    for user_id, cache_entry in user_cache.items():
        if current_time - cache_entry['timestamp'] > cache_timeout:
            expired_keys.append(user_id)
    
    for key in expired_keys:
        del user_cache[key]
    
    # Limpa dados de debug antigos
    debug_expired = []
    cutoff_time_debug = current_time - 3600  # 1 hora
    
    for key in list(command_executions.keys()):
        command_executions[key] = [
            exec_data for exec_data in command_executions[key]
            if (current_time - exec_data['timestamp'].timestamp()) < 3600
        ]
        if not command_executions[key]:
            debug_expired.append(key)
    
    for key in debug_expired:
        del command_executions[key]
    
    # Limpa alertas de duplica√ß√£o antigos
    alert_expired = []
    for alert_key in duplicate_alerts:
        # Remove alertas de mais de 1 hora
        if len(alert_key.split('_')) >= 3:
            try:
                alert_minute = int(alert_key.split('_')[-1])
                current_minute = datetime.now().minute
                if abs(current_minute - alert_minute) > 30:  # 30 minutos
                    alert_expired.append(alert_key)
            except:
                alert_expired.append(alert_key)
    
    for key in alert_expired:
        del duplicate_alerts[key]
    
    # Sistema antigo removido - o singleton help_manager j√° gerencia limpeza autom√°tica
    
    if expired_keys or debug_expired or alert_expired:
        logging.info(f"Cache limpo: {len(expired_keys)} usu√°rios, {len(debug_expired)} debug, {len(alert_expired)} alertas")

# ================= INICIALIZA√á√ÉO =================
@bot.event
async def on_ready():
    """Executa quando o bot est√° pronto"""
    print(f'‚úÖ Bot {bot.user} conectado com sucesso!')
    print(f'üìÇ Caminho do banco de dados: {DB_PATH}')
    
    # Inicializa o banco de permiss√µes
    try:
        init_perm_db()
        print("‚úÖ Banco de permiss√µes inicializado")
    except Exception as e:
        print(f"‚ùå Erro ao iniciar banco de permiss√µes: {e}")

    # Verifica√ß√£o robusta do banco de dados
    print("Testando conex√£o com o banco de dados...")
    try:
        with get_db() as conn:
            # Testa uma consulta simples e verifica estrutura
            conn.execute("SELECT 1").fetchone()
            
            # Verifica se as tabelas essenciais existem
            cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tabelas = [row['name'] for row in cursor]
            tabelas_essenciais = {'users', 'warns', 'families'}
            
            if not tabelas_essenciais.issubset(tabelas):
                print("‚ö†Ô∏è ATEN√á√ÉO: Algumas tabelas essenciais est√£o faltando!")
                print(f"Tabelas encontradas: {tabelas}")
                print(f"Tabelas esperadas: {tabelas_essenciais}")
            else:
                print("‚úÖ Banco de dados est√° acess√≠vel e com estrutura v√°lida")
                
    except Exception as e:
        print(f"‚ùå ERRO CR√çTICO NO BANCO DE DADOS: {e}")
        print("Recomenda√ß√µes:")
        print("1. Verifique as permiss√µes do arquivo do banco de dados")
        print("2. Confira se o arquivo n√£o est√° corrompido")
        print("3. Execute o comando !iniciar_emergencia se dispon√≠vel")
    
    # Verifica√ß√µes de canal e comandos
    voice_channel = bot.get_channel(VOICE_COUNTER_CHANNEL_ID)
    if not voice_channel:
        print(f"‚ö†Ô∏è Canal de contador de voz (ID: {VOICE_COUNTER_CHANNEL_ID}) n√£o encontrado!")
    
    if not verificar_comandos():
        print("‚ö†Ô∏è Alguns problemas foram encontrados na verifica√ß√£o de comandos!")
    
    # Inicia tarefas peri√≥dicas
    try:
        verificar_periodicamente.start()
        update_voice_counter.start()
        clear_cache.start()
        help_system_cleanup.start()
        logging.info("‚úÖ Todas as tarefas peri√≥dicas iniciadas com sucesso")
    except RuntimeError as e:
        logger.error(f"‚ö†Ô∏è Erro ao iniciar tarefas peri√≥dicas: {e}")
    
    # Status do bot
    await bot.change_presence(activity=discord.Activity(
        type=discord.ActivityType.watching,
        name="digite !f para ajuda"
    ))
    print("‚úÖ Status do bot definido com sucesso")
    print("üü¢ Bot totalmente operacional e pronto para uso!")

# ================= INICIALIZA√á√ÉO FINAL =================
if __name__ == '__main__':
    print(f"Tipo do bot confirmado: {type(bot)}")  # Deve mostrar <class '__main__.SafeBot'>
    load_dotenv()
    
    # Valida√ß√£o do token
    token = os.getenv('DISCORD_TOKEN')
    if not token:
        print("‚ùå ERRO: Token do Discord n√£o encontrado!")
        print("Crie um arquivo .env com: DISCORD_TOKEN=seu_token_aqui")
        sys.exit(1)
    
    # Inicializa√ß√£o do banco de dados
    try:
        init_perm_db()
        init_db()
        print("‚úÖ Banco de dados inicializado com sucesso")
    except Exception as e:
        print(f"‚ùå Erro ao inicializar banco de dados: {e}")
        sys.exit(1)
    
    # Execu√ß√£o do bot com tratamento de erros
    try:
        print("üöÄ Iniciando o bot...")
        bot.run(token)
    except discord.LoginFailure:
        print("‚ùå ERRO: Token inv√°lido! Verifique o token no arquivo .env")
    except discord.HTTPException as e:
        print(f"‚ùå ERRO HTTP: {e}")
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
    finally:
        print("üîÑ Bot finalizado")